# mojoèªè¨€åŸºæœ¬(.mojoæˆ–.ğŸ”¥)

## æ¶æ§‹
- #ä»‹ç´¹
- #mojoçš„é‹è¡Œ
- #èªå½™çµæ§‹
  - #var&let
- #è¨»è§£æ–¹å¼
- #å‹åˆ¥
  - #Intèˆ‡intçš„å·®åˆ¥
- #è®Šæ•¸
  - #å‘½åè¦å®š
- #é‹ç®—å¼åŠé‹ç®—å…ƒ
  - #é‹ç®—å¼
  - #é‹ç®—å…ƒ
- #è¿°å¥
- #è¿´åœˆ
  - #forloop
  - #while
  - #do-while
  - #forEach
  - #whileåŠdo-whileä¹‹å·®ç•°
- #ç‰©ä»¶
  - #é™£åˆ—
- #å‡½å¼
- #struct
- #ä¾‹å¤–è™•ç†
  - #ä¾‹å¤–ä»‹ç´¹
  - #è™•ç†ä¾‹å¤–
- #è¡¨å–®
- #è¨»è§£åŠåƒè¦‹
  - #é—œéµä¿ç•™å­— ä¸€è¦½

## #ä»‹ç´¹
Mojo æ˜¯ä¸€ç¨®èˆ‡ Python ä¸€æ¨£æ˜“æ–¼ä½¿ç”¨çš„ç·¨ç¨‹èªè¨€ï¼Œä½†å…·æœ‰ C++ å’Œ Rust çš„æ€§èƒ½ã€‚æ­¤å¤–ï¼ŒMojo é‚„æä¾›äº†åˆ©ç”¨æ•´å€‹ Python åº«ç”Ÿæ…‹ç³»çµ±çš„èƒ½åŠ›ã€‚
Mojo é€šéåˆ©ç”¨å…·æœ‰é›†æˆç·©å­˜ã€å¤šç·šç¨‹å’Œé›²åˆ†ç™¼æŠ€è¡“çš„ä¸‹ä¸€ä»£ç·¨è­¯å™¨æŠ€è¡“ä¾†å¯¦ç¾é€™ä¸€å£¯èˆ‰ã€‚æ­¤å¤–ï¼ŒMojo çš„è‡ªå‹•èª¿æ•´å’Œç·¨è­¯æ™‚å…ƒç·¨ç¨‹åŠŸèƒ½å…è¨±æ‚¨ç·¨å¯«å¯ç§»æ¤åˆ°æœ€å¥‡ç‰¹ç¡¬ä»¶çš„ä»£ç¢¼ã€‚
æ›´é‡è¦çš„æ˜¯ï¼ŒMojo å…è¨±æ‚¨åˆ©ç”¨æ•´å€‹ Python ç”Ÿæ…‹ç³»çµ±ï¼Œä»¥ä¾¿æ‚¨å¯ä»¥ç¹¼çºŒä½¿ç”¨æ‚¨ç†Ÿæ‚‰çš„å·¥å…·ã€‚Mojo æ—¨åœ¨é€šéä¿ç•™ Python çš„å‹•æ…‹åŠŸèƒ½åŒæ™‚æ·»åŠ æ–°çš„ç³»çµ±ç·¨ç¨‹åŸèªï¼Œéš¨è‘—æ™‚é–“çš„æ¨ç§»æˆç‚º Python çš„è¶…é›†ã€‚
é€™äº›æ–°çš„ç³»çµ±ç·¨ç¨‹åŸèªå°‡å…è¨± Mojo é–‹ç™¼äººå“¡æ§‹å»ºç›®å‰éœ€è¦ Cã€C++ã€Rustã€CUDA å’Œå…¶ä»–åŠ é€Ÿå™¨ç³»çµ±çš„é«˜æ€§èƒ½åº«ã€‚é€šéåŒ¯é›†æœ€å¥½çš„å‹•æ…‹èªè¨€å’Œç³»çµ±èªè¨€ï¼Œæˆ‘å€‘å¸Œæœ›æä¾›ä¸€å€‹çµ±ä¸€çš„è·¨æŠ½è±¡ç´šåˆ¥å·¥ä½œçš„ç·¨ç¨‹æ¨¡å‹å°æ–°æ‰‹ç¨‹åºå“¡å¾ˆå‹å¥½ï¼Œä¸¦ä¸”å¯ä»¥æ“´å±•åˆ°å¾åŠ é€Ÿå™¨åˆ°æ‡‰ç”¨ç¨‹åºç·¨ç¨‹å’Œè…³æœ¬ç·¨å¯«çš„è¨±å¤šç”¨ä¾‹ã€‚

## #mojoçš„é‹è¡Œ
ä½¿ç”¨ Mojo ç·¨è­¯å™¨
æ‚¨å¯ä»¥å¾çµ‚ç«¯é‹è¡Œ Mojo ç¨‹åºï¼Œå°±åƒä½¿ç”¨ Python ä¸€æ¨£ã€‚å› æ­¤ï¼Œå¦‚æœæ‚¨æœ‰ä¸€å€‹åç‚ºhello.mojoï¼ˆæˆ–hello.ğŸ”¥- æ˜¯çš„ï¼Œæ–‡ä»¶æ“´å±•åå¯ä»¥æ˜¯è¡¨æƒ…ç¬¦è™Ÿï¼ï¼‰çš„æ–‡ä»¶ï¼Œåªéœ€éµå…¥mojo hello.mojoï¼š

```cmd
$ cat hello.ğŸ”¥
def main():
    print("hello world")
    for x in range(9, 0, -3):
        print(x)
$ mojo hello.ğŸ”¥
hello world
9
6
3
$
```

## #var&let
è€ƒæ…®åˆ°æˆ‘å€‘çš„å…¼å®¹æ€§ç›®æ¨™ä»¥åŠ Python åœ¨é«˜ç´šæ‡‰ç”¨ç¨‹åºå’Œå‹•æ…‹ API æ–¹é¢çš„å„ªå‹¢ï¼Œæˆ‘å€‘ä¸å¿…èŠ±è²»å¤ªå¤šæ™‚é–“ä¾†è§£é‡‹è©²èªè¨€çš„é€™äº›éƒ¨åˆ†æ˜¯å¦‚ä½•å·¥ä½œçš„ã€‚å¦ä¸€æ–¹é¢ï¼ŒPython å°ç³»çµ±ç·¨ç¨‹çš„æ”¯æŒä¸»è¦å§”è¨—çµ¦ Cï¼Œæˆ‘å€‘å¸Œæœ›æä¾›ä¸€å€‹åœ¨è©²é ˜åŸŸéå¸¸å‡ºè‰²çš„å–®ä¸€ç³»çµ±ã€‚å› æ­¤ï¼Œæœ¬ç¯€è©³ç´°ä»‹ç´¹äº†æ¯å€‹ä¸»è¦çµ„ä»¶å’ŒåŠŸèƒ½ï¼Œä¸¦é€šéç¤ºä¾‹æè¿°ç­å¦‚ä½•ä½¿ç”¨å®ƒå€‘ã€‚

letå’Œvarè²æ˜
åœ¨ Mojo ä¸­çš„a å…§éƒ¨defï¼Œæ‚¨å¯ä»¥ç‚ºåç¨±åˆ†é…ä¸€å€‹å€¼ï¼Œå®ƒæœƒéš±å¼å‰µå»ºä¸€å€‹å‡½æ•¸ä½œç”¨åŸŸè®Šé‡ï¼Œå°±åƒåœ¨ Python ä¸­ä¸€æ¨£ã€‚é€™æä¾›äº†ä¸€ç¨®éå¸¸å‹•æ…‹ä¸”ç°¡å–®çš„ä»£ç¢¼ç·¨å¯«æ–¹å¼ï¼Œä½†å®ƒæ˜¯ä¸€å€‹æŒ‘æˆ°ï¼ŒåŸå› æœ‰äºŒï¼š

ç³»çµ±ç¨‹åºå“¡é€šå¸¸å¸Œæœ›è²æ˜ä¸€å€‹å€¼æ˜¯ä¸å¯è®Šçš„ï¼Œä»¥ä¿è­‰é¡å‹å®‰å…¨å’Œæ€§èƒ½ã€‚
å¦‚æœä»–å€‘åœ¨è³¦å€¼ä¸­è¼¸éŒ¯äº†è®Šé‡åï¼Œä»–å€‘å¯èƒ½å¸Œæœ›å¾—åˆ°ä¸€å€‹éŒ¯èª¤ã€‚
ç‚ºäº†æ”¯æŒé€™ä¸€é»ï¼ŒMojo æä¾›äº†ä½œç”¨åŸŸé‹è¡Œæ™‚å€¼è²æ˜ï¼šletæ˜¯ä¸å¯è®Šçš„ï¼Œä¸¦ä¸”varæ˜¯å¯è®Šçš„ã€‚é€™äº›å€¼ä½¿ç”¨è©æ³•ä½œç”¨åŸŸä¸¦æ”¯æŒåç¨±é®è”½ï¼š

def your_function(a, b):
    let c = a
    # Uncomment to see an error:
    # c = b  # error: c is immutable

    if c != b:
        let d = b
        print(d)

your_function(2, 3)

3
letå’Œvarè²æ˜æ”¯æŒé¡å‹èªªæ˜ç¬¦å’Œæ¨¡å¼ä»¥åŠå¾ŒæœŸåˆå§‹åŒ–ï¼š

def your_function():
    let x: Int = 42
    let y: Float64 = 17.0

    let z: Float32
    if x != 0:
        z = 1.0
    else:
        z = foo()
    print(z)

def foo() -> Float32:
    return 3.14

your_function()

1.0
è«‹æ³¨æ„ï¼Œåœ¨è²æ˜ä¸­letå’Œvaræ˜¯å®Œå…¨é¸æ“‡åŠ å…¥çš„defã€‚æ‚¨ä»ç„¶å¯ä»¥åƒä½¿ç”¨ Python ä¸€æ¨£ä½¿ç”¨éš±å¼è²æ˜çš„å€¼ï¼Œä¸¦ä¸”å®ƒå€‘ç…§å¸¸ç²å¾—å‡½æ•¸ä½œç”¨åŸŸã€‚

## #è¨»è§£æ–¹å¼
```mojo
# é€™æ˜¯ä¸€å€‹å–®è¡Œè¨»è§£

"""
é€™æ˜¯ä¸€å€‹
å¤šè¡Œè¨»è§£
"""
```

## #å‹åˆ¥
### #Intèˆ‡intçš„å·®åˆ¥
åœ¨ Mojo ä¸­ï¼Œæ‚¨å¯èƒ½æœƒæ³¨æ„åˆ°æˆ‘å€‘ä½¿ç”¨Intï¼ˆå¤§å¯«â€œIâ€ï¼‰ï¼Œé€™èˆ‡ Python intï¼ˆå°å¯«â€œiâ€ï¼‰ä¸åŒã€‚é€™ç¨®å·®ç•°æ˜¯æ•…æ„çš„ï¼Œè€Œä¸”å¯¦éš›ä¸Šæ˜¯ä¸€ä»¶å¥½äº‹ï¼
åœ¨ Python ä¸­ï¼Œè©²inté¡å‹å¯ä»¥è™•ç†éå¸¸å¤§çš„æ•¸å­—ï¼Œä¸¦ä¸”å…·æœ‰ä¸€äº›é¡å¤–çš„åŠŸèƒ½ï¼Œä¾‹å¦‚æª¢æŸ¥å…©å€‹æ•¸å­—æ˜¯å¦æ˜¯åŒä¸€å€‹å°è±¡ã€‚ä½†é€™å¸¶ä¾†äº†ä¸€äº›é¡å¤–çš„è² æ“”ï¼Œå¯èƒ½æœƒæ¸›æ…¢é€Ÿåº¦ã€‚Mojoçš„å‰‡Intä¸åŒã€‚å®ƒçš„è¨­è¨ˆç°¡å–®ã€å¿«é€Ÿï¼Œä¸¦é‡å°æ‚¨çš„è¨ˆç®—æ©Ÿç¡¬ä»¶é€²è¡Œäº†èª¿æ•´ï¼Œä»¥ä¾¿å¿«é€Ÿè™•ç†ã€‚
æˆ‘å€‘åšå‡ºé€™æ¨£çš„é¸æ“‡æœ‰å…©å€‹ä¸»è¦åŸå› ï¼š
æˆ‘å€‘å¸Œæœ›ç‚ºéœ€è¦èˆ‡è¨ˆç®—æ©Ÿç¡¬ä»¶å¯†åˆ‡åˆä½œçš„ç¨‹åºå“¡ï¼ˆç³»çµ±ç¨‹åºå“¡ï¼‰æä¾›ä¸€ç¨®é€æ˜ä¸”å¯é çš„èˆ‡ç¡¬ä»¶äº¤äº’çš„æ–¹å¼ã€‚æˆ‘å€‘ä¸æƒ³ä¾é èŠ±å“¨çš„æŠ€å·§ï¼ˆæ¯”å¦‚ JIT ç·¨è­¯å™¨ï¼‰ä¾†è®“äº‹æƒ…è®Šå¾—æ›´å¿«ã€‚
æˆ‘å€‘å¸Œæœ› Mojo èƒ½å¤ èˆ‡ Python å¾ˆå¥½åœ°é…åˆï¼Œè€Œä¸æœƒå¼•èµ·ä»»ä½•å•é¡Œã€‚é€šéä½¿ç”¨ä¸åŒçš„åç¨±ï¼ˆInt è€Œä¸æ˜¯ intï¼‰ï¼Œæˆ‘å€‘å¯ä»¥åœ¨ Mojo ä¸­ä¿ç•™é€™å…©ç¨®é¡å‹ï¼Œè€Œç„¡éœ€æ›´æ”¹ Python int çš„å·¥ä½œæ–¹å¼ã€‚
ä½œç‚ºçå‹µï¼ŒIntéµå¾ªèˆ‡æ‚¨å¯èƒ½åœ¨ Mojo ä¸­å‰µå»ºçš„å…¶ä»–è‡ªå®šç¾©æ•¸æ“šé¡å‹ç›¸åŒçš„å‘½åé¢¨æ ¼ã€‚æ­¤å¤–ï¼ŒIntå®ƒstructåŒ…å«åœ¨ Mojo çš„æ¨™æº–å·¥å…·é›†ä¸­ã€‚
å¼·é¡å‹æª¢æŸ¥
å„˜ç®¡æ‚¨ä»ç„¶å¯ä»¥åƒåœ¨ Python ä¸­ä¸€æ¨£ä½¿ç”¨éˆæ´»çš„é¡å‹ï¼Œä½† Mojo å…è¨±æ‚¨ä½¿ç”¨åš´æ ¼çš„é¡å‹æª¢æŸ¥ã€‚é¡å‹æª¢æŸ¥å¯ä»¥ä½¿æ‚¨çš„ä»£ç¢¼æ›´å¯é æ¸¬ã€æ›´æ˜“æ–¼ç®¡ç†ä¸”æ›´å®‰å…¨ã€‚
ä½¿ç”¨å¼·é¡å‹æª¢æŸ¥çš„ä¸»è¦æ–¹æ³•ä¹‹ä¸€æ˜¯ä½¿ç”¨ Mojo çš„structé¡å‹ã€‚Mojo ä¸­çš„å®šç¾©structå®šç¾©äº†ä¸€å€‹ç·¨è­¯æ™‚ç¶å®šçš„åç¨±ï¼Œä¸¦ä¸”åœ¨é¡å‹ä¸Šä¸‹æ–‡ä¸­å°è©²åç¨±çš„å¼•ç”¨è¢«è¦–ç‚ºæ‰€å®šç¾©å€¼çš„å¼·è¦ç¯„ã€‚ä¾‹å¦‚ï¼Œè€ƒæ…®ä»¥ä¸‹ä½¿ç”¨MyPairä¸Šé¢æ‰€ç¤ºçµæ§‹çš„ä»£ç¢¼ï¼š
def pair_test() -> Bool:
    let p = MyPair(1, 2)
    # Uncomment to see an error:
    # return p < 4 # gives a compile time error
    return True

å¦‚æœå–æ¶ˆè¨»é‡‹ç¬¬ä¸€å€‹ return èªå¥ä¸¦é‹è¡Œå®ƒï¼Œæ‚¨å°‡æ”¶åˆ°ä¸€å€‹ç·¨è­¯æ™‚éŒ¯èª¤ï¼Œå‘Šè¨´æ‚¨ç„¡æ³•4è½‰æ›ç‚ºMyPairï¼Œé€™æ˜¯ çš„ å³å´æ‰€__lt__()éœ€è¦çš„ï¼ˆåœ¨MyPairå®šç¾©ä¸­ï¼‰ã€‚
åœ¨ä½¿ç”¨ç³»çµ±ç·¨ç¨‹èªè¨€æ™‚ï¼Œé€™æ˜¯ä¸€ç¨®ç†Ÿæ‚‰çš„é«”é©—ï¼Œä½† Python ä¸¦ä¸æ˜¯é€™æ¨£å·¥ä½œçš„ã€‚Python å°æ–¼MyPyé¡å‹è¨»é‡‹å…·æœ‰èªæ³•ç›¸åŒçš„åŠŸèƒ½ï¼Œä½†å®ƒå€‘ä¸æ˜¯ç”±ç·¨è­¯å™¨å¼·åˆ¶åŸ·è¡Œçš„ï¼šç›¸åï¼Œå®ƒå€‘æ˜¯é€šçŸ¥éœæ…‹åˆ†æçš„æç¤ºã€‚é€šéå°‡é¡å‹ç¶å®šåˆ°ç‰¹å®šè²æ˜ï¼ŒMojo å¯ä»¥è™•ç†ç¶“å…¸é¡å‹è¨»é‡‹æç¤ºå’Œå¼·é¡å‹è¦ç¯„ï¼Œè€Œä¸æœƒç ´å£å…¼å®¹æ€§ã€‚
é¡å‹æª¢æŸ¥ä¸¦ä¸æ˜¯å¼·é¡å‹çš„å”¯ä¸€ç”¨ä¾‹ã€‚ç”±æ–¼æˆ‘å€‘çŸ¥é“é¡å‹æ˜¯æº–ç¢ºçš„ï¼Œå› æ­¤æˆ‘å€‘å¯ä»¥æ ¹æ“šé€™äº›é¡å‹å„ªåŒ–ä»£ç¢¼ï¼Œåœ¨å¯„å­˜å™¨ä¸­å‚³éå€¼ï¼Œä¸¦åœ¨åƒæ•¸å‚³éå’Œå…¶ä»–ä½ç´šç´°ç¯€æ–¹é¢èˆ‡ C ä¸€æ¨£é«˜æ•ˆã€‚é€™æ˜¯ Mojo ç‚ºç³»çµ±ç¨‹åºå“¡æä¾›å®‰å…¨æ€§å’Œå¯é æ¸¬æ€§ä¿è­‰çš„åŸºç¤ã€‚

##
##
##
##
##
##
##
##
##
##
##
##
##
##

## #å‡½å¼
é‡è¼‰çš„å‡½æ•¸å’Œæ–¹æ³•
èˆ‡ Python ä¸€æ¨£ï¼Œæ‚¨å¯ä»¥åœ¨ Mojo ä¸­å®šç¾©å‡½æ•¸è€Œç„¡éœ€æŒ‡å®šåƒæ•¸æ•¸æ“šé¡å‹ï¼ŒMojo å°‡å‹•æ…‹è™•ç†å®ƒå€‘ã€‚ç•¶æ‚¨æƒ³è¦å¯Œæœ‰è¡¨ç¾åŠ›çš„ API åªé€šéæ¥å—ä»»æ„è¼¸å…¥ä¸¦è®“å‹•æ…‹èª¿åº¦æ±ºå®šå¦‚ä½•è™•ç†æ•¸æ“šæ™‚ï¼Œé€™å¾ˆå¥½ã€‚ç„¶è€Œï¼Œç•¶æ‚¨æƒ³è¦ç¢ºä¿é¡å‹å®‰å…¨æ™‚ï¼Œå¦‚ä¸Šæ‰€è¿°ï¼ŒMojo é‚„æä¾›å°é‡è¼‰å‡½æ•¸å’Œæ–¹æ³•çš„å…¨é¢æ”¯æŒã€‚
é€™å…è¨±æ‚¨å®šç¾©å¤šå€‹å…·æœ‰ç›¸åŒåç¨±ä½†å…·æœ‰ä¸åŒåƒæ•¸çš„å‡½æ•¸ã€‚é€™æ˜¯è¨±å¤šèªè¨€ï¼ˆä¾‹å¦‚ C++ã€Java å’Œ Swiftï¼‰ä¸­çš„å¸¸è¦‹åŠŸèƒ½ã€‚
è§£æå‡½æ•¸èª¿ç”¨æ™‚ï¼ŒMojo æœƒå˜—è©¦æ¯å€‹å€™é¸è€…ä¸¦ä½¿ç”¨æœ‰æ•ˆçš„ä¸€å€‹ï¼ˆå¦‚æœåªæœ‰ä¸€å€‹æœ‰æ•ˆï¼‰ï¼Œæˆ–è€…é¸æ“‡æœ€æ¥è¿‘çš„åŒ¹é…ï¼ˆå¦‚æœå®ƒå¯ä»¥ç¢ºå®šæ¥è¿‘çš„åŒ¹é…ï¼‰ï¼Œæˆ–è€…å¦‚æœå®ƒç„¡æ³•ç¢ºå®šé¸æ“‡å“ªä¸€å€‹ï¼Œå‰‡å ±å‘Šè©²èª¿ç”¨ä¸æ˜ç¢ºã€‚åœ¨å¾Œä¸€ç¨®æƒ…æ³ä¸‹ï¼Œæ‚¨å¯ä»¥é€šéåœ¨èª¿ç”¨ç«™é»ä¸Šæ·»åŠ é¡¯å¼è½‰æ›ä¾†è§£æ±ºæ­§ç¾©ã€‚
è®“æˆ‘å€‘çœ‹ä¸€å€‹ä¾‹å­ï¼š
```mojo
struct Complex:
    var re: Float32
    var im: Float32

    fn __init__(inout self, x: Float32):
        """Construct a complex number given a real number."""
        self.re = x
        self.im = 0.0

    fn __init__(inout self, r: Float32, i: Float32):
        """Construct a complex number given its real and imaginary components."""
        self.re = r
        self.im = i
```
æ‚¨å¯ä»¥é‡è¼‰çµæ§‹å’Œé¡ä¸­çš„æ–¹æ³•ä»¥åŠé‡è¼‰æ¨¡å¡Šç´šå‡½æ•¸ã€‚
Mojo ä¸æ”¯æŒåƒ…åœ¨çµæœé¡å‹ä¸Šé‡è¼‰ï¼Œä¸¦ä¸”ä¸ä½¿ç”¨çµæœé¡å‹æˆ–ä¸Šä¸‹æ–‡é¡å‹ä¿¡æ¯é€²è¡Œé¡å‹æ¨æ–·ï¼Œå¾è€Œä½¿äº‹æƒ…ä¿æŒç°¡å–®ã€å¿«é€Ÿå’Œå¯é æ¸¬ã€‚Mojo æ°¸é ä¸æœƒç”¢ç”Ÿâ€œè¡¨é”å¼å¤ªè¤‡é›œâ€éŒ¯èª¤ï¼Œå› ç‚ºå®ƒçš„é¡å‹æª¢æŸ¥å™¨æ ¹æ“šå®šç¾©æ˜¯ç°¡å–®ä¸”å¿«é€Ÿçš„ã€‚
åŒæ¨£ï¼Œå¦‚æœæ‚¨çš„åƒæ•¸åç¨±ä¸å¸¶é¡å‹å®šç¾©ï¼Œå‰‡è©²å‡½æ•¸çš„è¡Œç‚ºå°±åƒå…·æœ‰å‹•æ…‹é¡å‹çš„ Python ä¸€æ¨£ã€‚ä¸€æ—¦å®šç¾©äº†å–®å€‹åƒæ•¸é¡å‹ï¼ŒMojo å°‡æŸ¥æ‰¾é‡è¼‰å€™é¸è€…ä¸¦è§£æå‡½æ•¸èª¿ç”¨ï¼Œå¦‚ä¸Šæ‰€è¿°ã€‚
é›–ç„¶æˆ‘å€‘é‚„æ²’æœ‰è¨è«–åƒæ•¸ï¼ˆå®ƒå€‘èˆ‡å‡½æ•¸åƒæ•¸ä¸åŒï¼‰ï¼Œä½†æ‚¨ä¹Ÿå¯ä»¥åŸºæ–¼åƒæ•¸é‡è¼‰å‡½æ•¸å’Œæ–¹æ³•ã€‚
fnå®šç¾©
ä¸Šè¿°æ“´å±•æ˜¯æä¾›ä½ç´šç·¨ç¨‹å’ŒæŠ½åƒåŠŸèƒ½çš„åŸºçŸ³ï¼Œä½†è¨±å¤šç³»çµ±ç¨‹åºå“¡æ›´å–œæ­¡æ¯”defMojo æä¾›çš„æ›´å¤šæ§åˆ¶å’Œå¯é æ¸¬æ€§ã€‚å›é¡§ä¸€ä¸‹ï¼Œdefå®ƒçš„å®šç¾©å¿…é ˆéå¸¸å‹•æ…‹ã€éˆæ´»ä¸¦ä¸”é€šå¸¸èˆ‡ Python å…¼å®¹ï¼šåƒæ•¸æ˜¯å¯è®Šçš„ï¼Œå±€éƒ¨è®Šé‡åœ¨ç¬¬ä¸€æ¬¡ä½¿ç”¨æ™‚éš±å¼è²æ˜ï¼Œä¸¦ä¸”ä¸å¼·åˆ¶åŸ·è¡Œä½œç”¨åŸŸã€‚é€™å°æ–¼é«˜ç´šç·¨ç¨‹å’Œè…³æœ¬ç·¨å¯«ä¾†èªªéå¸¸æœ‰ç”¨ï¼Œä½†å°æ–¼ç³»çµ±ç·¨ç¨‹ä¾†èªªä¸¦ä¸ç¸½æ˜¯é‚£éº¼å¥½ã€‚ç‚ºäº†è£œå……é€™ä¸€é»ï¼ŒMojo æä¾›äº†ä¸€å€‹fné¡ä¼¼æ–¼def.
fnæ›¿ä»£æ–¹æ¡ˆï¼šæˆ‘å€‘å¯ä»¥æ·»åŠ ä¿®é£¾ç¬¦æˆ–è£é£¾å™¨ï¼Œè€Œä¸æ˜¯ä½¿ç”¨åƒ é€™æ¨£çš„æ–°é—œéµå­—@strict defã€‚ç„¶è€Œï¼Œç„¡è«–å¦‚ä½•æˆ‘å€‘éƒ½éœ€è¦æ¡ç”¨æ–°çš„é—œéµè©ï¼Œè€Œä¸”é€™æ¨£åšçš„æˆæœ¬å¾ˆä½ã€‚æ­¤å¤–ï¼Œåœ¨ç³»çµ±ç·¨ç¨‹é ˜åŸŸçš„å¯¦è¸ä¸­ï¼Œfnå®ƒä¸€ç›´è¢«ä½¿ç”¨ï¼Œå› æ­¤ä½¿å…¶æˆç‚ºä¸€æµå¯èƒ½æ˜¯æœ‰æ„ç¾©çš„ã€‚
å°±èª¿ç”¨è€…è€Œè¨€ï¼Œfnå’Œdefæ˜¯å¯ä»¥äº’æ›çš„ï¼šæ²’æœ‰ä»€éº¼æ˜¯defå¯ä»¥æä¾›è€Œfnä¸èƒ½æä¾›çš„ï¼ˆåä¹‹äº¦ç„¶ï¼‰ã€‚ä¸åŒä¹‹è™•åœ¨æ–¼ï¼Œåœ¨å…¶å…§éƒ¨fnå—åˆ°æ›´å¤šé™åˆ¶å’Œæ§åˆ¶ï¼ˆæˆ–è€…ï¼šè¿‚è…å’Œåš´æ ¼ï¼‰ã€‚å…·é«”ä¾†èªªèˆ‡defç›¸æ¯”fnæœ‰è¨±å¤šé™åˆ¶
åƒæ•¸å€¼é»˜èªåœ¨å‡½æ•¸é«”å…§æ˜¯ä¸å¯è®Šçš„ï¼ˆå¦‚ letï¼‰ï¼Œè€Œä¸æ˜¯å¯è®Šçš„ï¼ˆå¦‚ varï¼‰ã€‚é€™æœƒæ•ç²æ„å¤–çªè®Šï¼Œä¸¦å…è¨±ä½¿ç”¨ä¸å¯è¤‡åˆ¶çš„é¡å‹ä½œç‚ºåƒæ•¸ã€‚
åƒæ•¸å€¼éœ€è¦é¡å‹è¦ç¯„ï¼ˆselfæ–¹æ³•ä¸­é™¤å¤–ï¼‰ï¼Œä»¥æ•ç²é¡å‹è¦ç¯„çš„æ„å¤–éºæ¼ã€‚åŒæ¨£ï¼Œç¼ºå°‘è¿”å›é¡å‹èªªæ˜ç¬¦æœƒè¢«è§£é‡‹ç‚ºè¿”å›Noneè€Œä¸æ˜¯æœªçŸ¥çš„è¿”å›é¡å‹ã€‚è«‹æ³¨æ„ï¼Œå…©è€…éƒ½å¯ä»¥é¡¯å¼è²æ˜ç‚º return ï¼Œé€™å…è¨±äººå€‘æ ¹æ“šéœ€è¦objecté¸æ“‡åŠ å…¥çš„è¡Œç‚ºã€‚def
å±€éƒ¨è®Šé‡çš„éš±å¼è²æ˜è¢«ç¦ç”¨ï¼Œå› æ­¤å¿…é ˆè²æ˜æ‰€æœ‰å±€éƒ¨è®Šé‡ã€‚leté€™å¯ä»¥æ•ç²åç¨±æ‹¼å¯«éŒ¯èª¤ä¸¦èˆ‡å’Œæä¾›çš„ç¯„åœç›¸å»åˆvarã€‚
å…©è€…éƒ½æ”¯æŒå¼•ç™¼ç•°å¸¸ï¼Œä½†å¿…é ˆä½¿ç”¨é—œéµå­—é¡¯å¼fnè²æ˜raisesã€‚
ä¸åŒåœ˜éšŠçš„ç·¨ç¨‹æ¨¡å¼æœƒæœ‰å¾ˆå¤§å·®ç•°ï¼Œé€™ç¨®åš´æ ¼ç¨‹åº¦ä¸¦ä¸é©åˆæ‰€æœ‰äººã€‚æˆ‘å€‘å¸Œæœ›ç¿’æ…£ C++ ä¸¦å·²åœ¨ Python ä¸­ä½¿ç”¨ MyPy é¢¨æ ¼é¡å‹è¨»é‡‹çš„äººå€‘æ›´å–œæ­¡ä½¿ç”¨fnsï¼Œä½†æ›´é«˜ç´šåˆ¥çš„ç¨‹åºå“¡å’Œ ML ç ”ç©¶äººå“¡å°‡ç¹¼çºŒä½¿ç”¨def. Mojo å…è¨±æ‚¨è‡ªç”±åœ°æ··åˆdefå’Œfnè²æ˜ï¼Œä¾‹å¦‚ç”¨ä¸€ç¨®æ–¹æ³•å¯¦ç¾æŸäº›æ–¹æ³•ï¼Œç”¨å¦ä¸€ç¨®æ–¹â€‹â€‹æ³•å¯¦ç¾å¦ä¸€äº›æ–¹æ³•ï¼Œä¸¦å…è¨±æ¯å€‹åœ˜éšŠæˆ–ç¨‹åºå“¡æ±ºå®šä»€éº¼æœ€é©åˆä»–å€‘çš„ç”¨ä¾‹ã€‚
æœ‰é—œ Mojo å‡½æ•¸ä¸­åƒæ•¸è¡Œç‚ºçš„æ›´å¤šä¿¡æ¯ï¼Œè«‹åƒé–±ä¸‹é¢æœ‰é—œåƒæ•¸å‚³éæ§åˆ¶å’Œå…§å­˜æ‰€æœ‰æ¬Šçš„éƒ¨åˆ†ã€‚
æ–¹æ³•__copyinit__åŠ__moveinit__ç‰¹æ®Šæ–¹æ³•
Mojo æ”¯æŒå®Œæ•´çš„â€œå€¼èªç¾©â€ï¼Œå¦‚ C++ å’Œ Swift ç­‰èªè¨€ä¸­æ‰€ç¤ºï¼Œä¸¦ä¸”å®ƒä½¿å¾—ä½¿ç”¨è£é£¾å™¨å®šç¾©ç°¡å–®çš„å­—æ®µèšåˆè®Šå¾—éå¸¸@valueå®¹æ˜“ã€‚
å°æ–¼é«˜ç´šç”¨ä¾‹ï¼ŒMojo å…è¨±æ‚¨å®šç¾©è‡ªå®šç¾©æ§‹é€ å‡½æ•¸ï¼ˆä½¿ç”¨ Python ç¾æœ‰çš„__init__ç‰¹æ®Šæ–¹æ³•ï¼‰ã€è‡ªå®šç¾©ææ§‹å‡½æ•¸ï¼ˆä½¿ç”¨ç¾æœ‰çš„ç‰¹æ®Šæ–¹æ³•ï¼‰ä»¥åŠä½¿ç”¨æ–°çš„ç‰¹æ®Šæ–¹æ³•çš„__del__è‡ªå®šç¾©å¾©åˆ¶å’Œç§»å‹•æ§‹é€ å‡½æ•¸ã€‚__copyinit____moveinit__
é€™äº›ä½ç´šå®šåˆ¶æ›é‰¤åœ¨é€²è¡Œä½ç´šç³»çµ±ç·¨ç¨‹ï¼ˆä¾‹å¦‚æ‰‹å‹•å…§å­˜ç®¡ç†ï¼‰æ™‚éå¸¸æœ‰ç”¨ã€‚ä¾‹å¦‚ï¼Œè€ƒæ…®ä¸€å€‹å‹•æ…‹å­—ç¬¦ä¸²é¡å‹ï¼Œå®ƒéœ€è¦åœ¨æ§‹é€ æ™‚ç‚ºå­—ç¬¦ä¸²æ•¸æ“šåˆ†é…å…§å­˜ï¼Œä¸¦åœ¨éŠ·æ¯€å€¼æ™‚éŠ·æ¯€å®ƒï¼š
```mojo
from Pointer import Pointer
from IO import print_no_newline

struct HeapArray:
    var data: Pointer[Int]
    var size: Int
    var cap: Int

    fn __init__(inout self):
        self.cap = 16
        self.size = 0
        self.data = Pointer[Int].alloc(self.cap)

    fn __init__(inout self, size: Int, val: Int):
        self.cap = size * 2
        self.size = size
        self.data = Pointer[Int].alloc(self.cap)
        for i in range(self.size):
            self.data.store(i, val)

    fn __del__(owned self):
        self.data.free()

    fn dump(self):
        print_no_newline("[")
        for i in range(self.size):
            if i > 0:
                print_no_newline(", ")
            print_no_newline(self.data.load(i))
        print("]")
```
è©²æ•¸çµ„é¡å‹æ˜¯ä½¿ç”¨ä½ç´šå‡½æ•¸å¯¦ç¾çš„ï¼Œä»¥å±•ç¤ºå…¶å·¥ä½œåŸç†çš„ç°¡å–®ç¤ºä¾‹ã€‚HeapArrayä½†æ˜¯ï¼Œå¦‚æœæ‚¨å˜—è©¦ä½¿ç”¨é‹ç®—ç¬¦è¤‡è£½ çš„å¯¦ä¾‹=ï¼Œæ‚¨å¯èƒ½æœƒæ„Ÿåˆ°é©šè¨ï¼š
```mojo
var a = HeapArray(3, 1)
a.dump()   # Should print [1, 1, 1]
# Uncomment to see an error:
# var b = a  # ERROR: Vector doesn't implement __copyinit__

var b = HeapArray(4, 2)
b.dump()   # Should print [2, 2, 2, 2]
a.dump()   # Should print [1, 1, 1]

"""
[1, 1, 1]
[2, 2, 2, 2]
[1, 1, 1]
"""
```
å¦‚æœå–æ¶ˆè¨»é‡‹è¦å¾©è£½aåˆ° çš„è¡Œbï¼Œæ‚¨å°‡çœ‹åˆ° Mojo ä¸å…è¨±æ‚¨è¤‡è£½æˆ‘å€‘çš„æ•¸çµ„ï¼šHeapArrayåŒ…å«ä¸€å€‹å¯¦ä¾‹Pointerï¼ˆç›¸ç•¶æ–¼ä½ç´š C æŒ‡é‡ï¼‰ï¼Œä¸¦ä¸” Mojo ä¸çŸ¥é“å®ƒæŒ‡å‘ä»€éº¼é¡å‹çš„æ•¸æ“šæˆ–å¦‚ä½•å¾©åˆ¶å®ƒã€‚æ›´ä¸€èˆ¬åœ°èªªï¼ŒæŸäº›é¡å‹ï¼ˆå¦‚åŸå­åºæ•¸ï¼‰ç„¡æ³•è¤‡è£½æˆ–ç§»å‹•ï¼Œå› ç‚ºå®ƒå€‘çš„åœ°å€æä¾›äº†ä¸€å€‹èº«ä»½ï¼Œå°±åƒé¡å¯¦ä¾‹ä¸€æ¨£ã€‚
åœ¨é€™ç¨®æƒ…æ³ä¸‹ï¼Œæˆ‘å€‘ç¢ºå¯¦å¸Œæœ›æˆ‘å€‘çš„æ•¸çµ„æ˜¯å¯è¤‡åˆ¶çš„ã€‚ç‚ºäº†å¯¦ç¾é€™ä¸€é»ï¼Œæˆ‘å€‘å¿…é ˆå¯¦ç¾__copyinit__ç‰¹æ®Šçš„æ–¹æ³•ï¼Œé€šå¸¸æ˜¯é€™æ¨£å¯¦ç¾çš„ï¼š
```mojo
struct HeapArray:
    var data: Pointer[Int]
    var size: Int
    var cap: Int

    fn __init__(inout self):
        self.cap = 16
        self.size = 0
        self.data = Pointer[Int].alloc(self.cap)

    fn __init__(inout self, size: Int, val: Int):
        self.cap = size * 2
        self.size = size
        self.data = Pointer[Int].alloc(self.cap)
        for i in range(self.size):
            self.data.store(i, val)

    fn __copyinit__(inout self, other: Self):
        self.cap = other.cap
        self.size = other.size
        self.data = Pointer[Int].alloc(self.cap)
        for i in range(self.size):
            self.data.store(i, other.data.load(i))

    fn __del__(owned self):
        self.data.free()

    fn dump(self):
        print_no_newline("[")
        for i in range(self.size):
            if i > 0:
                print_no_newline(", ")
            print_no_newline(self.data.load(i))
        print("]")
```
é€šéæ­¤å¯¦ç¾ï¼Œæˆ‘å€‘ä¸Šé¢çš„ä»£ç¢¼å¯ä»¥æ­£å¸¸å·¥ä½œï¼Œä¸¦ä¸”b = aå‰¯æœ¬æœƒç”Ÿæˆé‚è¼¯ä¸Šä¸åŒçš„æ•¸çµ„å¯¦ä¾‹ï¼Œä¸¦å…·æœ‰è‡ªå·±çš„ç”Ÿå‘½é€±æœŸå’Œæ•¸æ“šï¼š
```mojo
var a = HeapArray(3, 1)
a.dump()   # Should print [1, 1, 1]
# This is no longer an error:
var b = a

b.dump()   # Should print [1, 1, 1]
a.dump()   # Should print [1, 1, 1]
"""
[1, 1, 1]
[1, 1, 1]
[1, 1, 1]
"""
```
Mojo é‚„æ”¯æŒ__moveinit__å…è¨± Rust é¢¨æ ¼çš„ç§»å‹•ï¼ˆåœ¨ç”Ÿå‘½é€±æœŸçµæŸæ™‚ç²å–å€¼ï¼‰å’Œ C++ é¢¨æ ¼çš„ç§»å‹•ï¼ˆå…¶ä¸­å€¼çš„å…§å®¹è¢«åˆªé™¤ä½†ææ§‹å‡½æ•¸ä»ç„¶é‹è¡Œï¼‰çš„æ–¹æ³•ï¼Œä¸¦å…è¨±å®šç¾©è‡ªå®šç¾©ç§»å‹•é‚è¼¯ã€‚æœ‰é—œæ›´å¤šè©³ç´°ä¿¡æ¯ï¼Œè«‹åƒé–±ä¸‹é¢çš„â€œåƒ¹å€¼ç”Ÿå‘½é€±æœŸâ€éƒ¨åˆ†ã€‚

Mojo æä¾›å°å€¼çš„ç”Ÿå‘½é€±æœŸçš„å®Œå…¨æ§åˆ¶ï¼ŒåŒ…æ‹¬ä½¿é¡å‹å¯è¤‡åˆ¶ã€åƒ…ç§»å‹•å’Œä¸å¯ç§»å‹•çš„èƒ½åŠ›ã€‚é€™æ¯” Swift å’Œ Rust ç­‰èªè¨€æä¾›çš„æ§åˆ¶èƒ½åŠ›æ›´å¼·ï¼Œå¾Œè€…è¦æ±‚å€¼è‡³å°‘æ˜¯å¯ç§»å‹•çš„ã€‚å¦‚æœæ‚¨å¥½å¥‡å¦‚ä½•åœ¨ä¸å‰µå»ºå‰¯æœ¬çš„æƒ…æ³ä¸‹existingå‚³éåˆ°æ–¹æ³•ä¸­ï¼Œè«‹æŸ¥çœ‹ä¸‹é¢æœ‰é—œå€Ÿç”¨åƒæ•¸çš„éƒ¨åˆ†ã€‚__copyinit__


## #struct
Mojo åŸºæ–¼ MLIR å’Œ LLVMï¼Œæä¾›äº†ç”¨æ–¼å¤šç¨®ç·¨ç¨‹èªè¨€çš„å°–ç«¯ç·¨è­¯å™¨å’Œä»£ç¢¼ç”Ÿæˆç³»çµ±ã€‚é€™è®“æˆ‘å€‘å¯ä»¥æ›´å¥½åœ°æ§åˆ¶æ•¸æ“šçµ„ç¹”ã€ç›´æ¥è¨ªå•æ•¸æ“šå­—æ®µä»¥åŠå…¶ä»–æé«˜æ€§èƒ½çš„æ–¹æ³•ã€‚ç¾ä»£ç³»çµ±ç·¨ç¨‹èªè¨€çš„ä¸€å€‹é‡è¦ç‰¹å¾µæ˜¯èƒ½å¤ åœ¨é€™äº›è¤‡é›œçš„ä½ç´šæ“ä½œä¹‹ä¸Šæ§‹å»ºé«˜ç´šä¸”å®‰å…¨çš„æŠ½è±¡ï¼Œè€Œä¸æœƒé€ æˆä»»ä½•æ€§èƒ½æå¤±ã€‚åœ¨ Mojo ä¸­ï¼Œé€™æ˜¯ç”±structé¡å‹æä¾›çš„ã€‚
Mojo ä¸­çš„Astructèˆ‡ Python é¡ä¼¼classï¼šå®ƒå€‘éƒ½æ”¯æŒæ–¹æ³•ã€å­—æ®µã€é‹ç®—ç¬¦é‡è¼‰ã€å…ƒç·¨ç¨‹è£é£¾å™¨ç­‰ã€‚å®ƒå€‘çš„å€åˆ¥å¦‚ä¸‹ï¼š
Python é¡æ˜¯å‹•æ…‹çš„ï¼šå®ƒå€‘å…è¨±å‹•æ…‹èª¿åº¦ã€çŒ´å­ä¿®è£œï¼ˆæˆ–â€œswizzlingâ€ï¼‰ä»¥åŠåœ¨é‹è¡Œæ™‚å‹•æ…‹ç¶å®šå¯¦ä¾‹å±¬æ€§ã€‚
Mojo çµæ§‹æ˜¯éœæ…‹çš„ï¼šå®ƒå€‘åœ¨ç·¨è­¯æ™‚ç¶å®šï¼ˆä¸èƒ½åœ¨é‹è¡Œæ™‚æ·»åŠ æ–¹æ³•ï¼‰ã€‚çµæ§‹å…è¨±æ‚¨ä»¥éˆæ´»æ€§æ›å–æ€§èƒ½ï¼ŒåŒæ™‚å®‰å…¨ä¸”æ˜“æ–¼ä½¿ç”¨ã€‚
é€™æ˜¯çµæ§‹é«”çš„ç°¡å–®å®šç¾©ï¼š
```mojo
struct MyPair:
    var first: Int
    var second: Int

    # We use 'fn' instead of 'def' here - we'll explain that soon
    fn __init__(inout self, first: Int, second: Int):
        self.first = first
        self.second = second

    fn __lt__(self, rhs: MyPair) -> Bool:
        return self.first < rhs.first or
              (self.first == rhs.first and
               self.second < rhs.second)
```

å¾èªæ³•ä¸Šè¬›èˆ‡Pythonçš„classç›¸æ¯”çš„æœ€å¤§å€åˆ¥æ˜¯structä¸­çš„æ‰€æœ‰å¯¦ä¾‹å±¬æ€§**å¿…é ˆ**ä½¿ç”¨varæˆ–è²æ˜é¡¯å¼letè²æ˜ã€‚
åœ¨Mojoä¸­ï¼Œâ€œçµæ§‹â€çš„çµæ§‹å’Œå…§å®¹æ˜¯é å…ˆè¨­ç½®çš„ï¼Œä¸¦ä¸”åœ¨ç¨‹åºé‹è¡Œæ™‚ä¸èƒ½æ›´æ”¹ã€‚èˆ‡ Python ä¸åŒçš„æ˜¯ï¼Œåœ¨ Python ä¸­æ‚¨å¯ä»¥å‹•æ…‹æ·»åŠ ã€åˆªé™¤æˆ–æ›´æ”¹å°è±¡çš„å±¬æ€§ï¼Œè€Œ Mojo ä¸å…è¨±å°çµæ§‹é€²è¡Œé€™ç¨®æ“ä½œã€‚é€™æ„å‘³è‘—æ‚¨ä¸èƒ½delåœ¨ç¨‹åºé‹è¡Œéç¨‹ä¸­åˆªé™¤æ–¹æ³•æˆ–æ›´æ”¹å…¶å€¼ã€‚
ç„¶è€Œï¼Œéœæ…‹ç‰¹æ€§structæœ‰ä¸€äº›å¾ˆå¤§çš„å¥½è™•ï¼å®ƒå¯ä»¥å¹«åŠ© Mojo æ›´å¿«åœ°é‹è¡Œæ‚¨çš„ä»£ç¢¼ã€‚ç¨‹åºç¢ºåˆ‡åœ°çŸ¥é“åœ¨å“ªè£¡å¯ä»¥æ‰¾åˆ°çµæ§‹é«”çš„ä¿¡æ¯ä»¥åŠå¦‚ä½•ä½¿ç”¨å®ƒï¼Œè€Œç„¡éœ€ä»»ä½•é¡å¤–çš„æ­¥é©Ÿæˆ–å»¶é²ã€‚
Mojo çš„çµæ§‹ä¹Ÿå¯ä»¥å¾ˆå¥½åœ°èˆ‡æ‚¨å¯èƒ½å·²ç¶“å¾ Python ä¸­äº†è§£çš„åŠŸèƒ½é…åˆä½¿ç”¨ï¼Œä¾‹å¦‚é‹ç®—ç¬¦é‡è¼‰ï¼ˆå®ƒå¯ä»¥è®“æ‚¨æ›´æ”¹æ•¸å­¸ç¬¦è™Ÿå°æ‚¨è‡ªå·±çš„æ•¸æ“šçš„å–œæ„›+å’Œä½¿ç”¨æ–¹å¼ï¼‰ã€‚-æ­¤å¤–ï¼Œæ‰€æœ‰â€œæ¨™æº–é¡å‹â€ï¼ˆä¾‹å¦‚Intã€Boolã€Stringç”šè‡³Tupleï¼‰éƒ½æ˜¯ä½¿ç”¨çµæ§‹é«”å‰µå»ºçš„ã€‚é€™æ„å‘³è‘—å®ƒå€‘æ˜¯æ‚¨å¯ä»¥ä½¿ç”¨çš„æ¨™æº–å·¥å…·é›†çš„ä¸€éƒ¨åˆ†ï¼Œè€Œä¸æ˜¯ç¡¬é€£æ¥åˆ°èªè¨€æœ¬èº«ä¸­ã€‚é€™ç‚ºæ‚¨åœ¨ç·¨å¯«ä»£ç¢¼æ™‚æä¾›äº†æ›´å¤§çš„éˆæ´»æ€§å’Œæ§åˆ¶åŠ›ã€‚
å¦‚æœæ‚¨æƒ³çŸ¥é“åƒæ•¸inoutçš„å«ç¾©selfï¼šé€™è¡¨æ˜åƒæ•¸æ˜¯å¯è®Šçš„ï¼Œä¸¦ä¸”å‡½æ•¸å…§éƒ¨æ‰€åšçš„æ›´æ”¹å°èª¿ç”¨è€…å¯è¦‹ã€‚æœ‰é—œè©³ç´°ä¿¡æ¯ï¼Œè«‹åƒé–±ä¸‹é¢æœ‰é—œinout Arguments çš„å…§å®¹ã€‚


## è¨»è§£åŠåƒè¦‹

[ç°¡å¯«ä¸€è¦½](abbreviationslist.md)






åƒæ•¸å‚³éæ§åˆ¶å’Œå…§å­˜æ‰€æœ‰æ¬Š
åœ¨ Python å’Œ Mojo ä¸­ï¼Œå¤§éƒ¨åˆ†èªè¨€éƒ½åœç¹å‡½æ•¸èª¿ç”¨ï¼šè¨±å¤šï¼ˆé¡¯ç„¶ï¼‰å…§ç½®è¡Œç‚ºæ˜¯åœ¨æ¨™æº–åº«ä¸­ä½¿ç”¨â€œdunderâ€ï¼ˆé›™ä¸‹åŠƒç·šï¼‰æ–¹æ³•å¯¦ç¾çš„ã€‚åœ¨é€™äº›ç¥å¥‡çš„å‡½æ•¸å…§éƒ¨ï¼Œè¨±å¤šå…§å­˜æ‰€æœ‰æ¬Šæ˜¯é€šéåƒæ•¸å‚³éä¾†ç¢ºå®šçš„ã€‚
è®“æˆ‘å€‘å›é¡§ä¸€ä¸‹æœ‰é—œ Python å’Œ Mojo å¦‚ä½•å‚³éåƒæ•¸çš„ä¸€äº›ç´°ç¯€ï¼š
å‚³éåˆ°Python defå‡½æ•¸çš„æ‰€æœ‰å€¼éƒ½ä½¿ç”¨å¼•ç”¨èªç¾©ã€‚é€™æ„å‘³è‘—è©²å‡½æ•¸å¯ä»¥ä¿®æ”¹å‚³éçµ¦å®ƒçš„å¯è®Šå°è±¡ï¼Œä¸¦ä¸”é€™äº›æ›´æ”¹åœ¨å‡½æ•¸å¤–éƒ¨å¯è¦‹ã€‚ç„¶è€Œï¼Œé€™ç¨®è¡Œç‚ºæœ‰æ™‚æœƒè®“å¤–è¡Œäººæ„Ÿåˆ°é©šè¨ï¼Œå› ç‚ºæ‚¨å¯ä»¥æ›´æ”¹åƒæ•¸æŒ‡å‘çš„å°è±¡ï¼Œä¸¦ä¸”è©²æ›´æ”¹åœ¨å‡½æ•¸å¤–éƒ¨ä¸å¯è¦‹ã€‚
é»˜èªæƒ…æ³ä¸‹ï¼Œå‚³éåˆ°Mojo defå‡½æ•¸çš„æ‰€æœ‰å€¼éƒ½ä½¿ç”¨å€¼èªç¾©ã€‚èˆ‡ Python ç›¸æ¯”ï¼Œé€™æ˜¯ä¸€å€‹é‡è¦çš„å€åˆ¥ï¼šMojodefå‡½æ•¸æ¥æ”¶æ‰€æœ‰åƒæ•¸çš„å‰¯æœ¬ - å®ƒå¯ä»¥ä¿®æ”¹å‡½æ•¸å…§éƒ¨çš„åƒæ•¸ï¼Œä½†æ›´æ”¹åœ¨å‡½æ•¸å¤–éƒ¨ä¸å¯è¦‹ã€‚
é»˜èªæƒ…æ³ä¸‹ï¼Œå‚³éåˆ° Mojofnå‡½æ•¸çš„æ‰€æœ‰å€¼éƒ½æ˜¯ä¸å¯è®Šå¼•ç”¨ã€‚é€™æ„å‘³è‘—è©²å‡½æ•¸å¯ä»¥è®€å–åŸå§‹å°è±¡ï¼ˆå®ƒä¸æ˜¯å‰¯æœ¬ï¼‰ï¼Œä½†å®ƒæ ¹æœ¬ç„¡æ³•ä¿®æ”¹è©²å°è±¡ã€‚
é€™ç¨®åœ¨ Mojo ä¸­å‚³éä¸å¯è®Šåƒæ•¸çš„ç´„å®šfnç¨±ç‚ºâ€œå€Ÿç”¨â€ã€‚åœ¨ä»¥ä¸‹éƒ¨åˆ†ä¸­ï¼Œæˆ‘å€‘å°‡è§£é‡‹å¦‚ä½•æ›´æ”¹ Mojo ä¸­defå’Œfnå‡½æ•¸çš„åƒæ•¸å‚³éè¡Œç‚ºã€‚
ç‚ºä»€éº¼è«–è­‰ç´„å®šå¾ˆé‡è¦
åœ¨ Python ä¸­ï¼Œæ‰€æœ‰åŸºæœ¬å€¼éƒ½æ˜¯å°å°è±¡çš„å¼•ç”¨ - å¦‚ä¸Šæ‰€è¿°ï¼ŒPython å‡½æ•¸å¯ä»¥ä¿®æ”¹åŸå§‹å°è±¡ã€‚å› æ­¤ï¼ŒPython é–‹ç™¼äººå“¡ç¿’æ…£æ–¼å°‡ä¸€åˆ‡éƒ½è¦–ç‚ºåƒè€ƒèªç¾©ã€‚ç„¶è€Œï¼Œåœ¨ CPython æˆ–æ©Ÿå™¨ç´šåˆ¥ï¼Œæ‚¨å¯ä»¥çœ‹åˆ°å¼•ç”¨æœ¬èº«å¯¦éš›ä¸Šæ˜¯é€šéè¤‡è£½å‚³éçš„- Python è¤‡è£½æŒ‡é‡ä¸¦èª¿æ•´å¼•ç”¨è¨ˆæ•¸ã€‚
é€™ç¨® Python æ–¹æ³•ç‚ºå¤§å¤šæ•¸äººæä¾›äº†ä¸€å€‹èˆ’é©çš„ç·¨ç¨‹æ¨¡å‹ï¼Œä½†å®ƒè¦æ±‚æ‰€æœ‰å€¼éƒ½é€²è¡Œå †åˆ†é…ï¼ˆç”±æ–¼å¼•ç”¨å…±äº«ï¼Œçµæœæœ‰æ™‚æœƒä»¤äººé©šè¨ï¼‰ã€‚Mojo é¡ï¼ˆTODOï¼šå°‡ï¼‰å°å¤§å¤šæ•¸å°è±¡éµå¾ªç›¸åŒçš„å¼•ç”¨èªç¾©æ–¹æ³•ï¼Œä½†é€™å°æ–¼ç³»çµ±ç·¨ç¨‹ä¸Šä¸‹æ–‡ä¸­çš„æ•´æ•¸ç­‰ç°¡å–®é¡å‹ä¾†èªªä¸¦ä¸å¯¦ç”¨ã€‚åœ¨é€™äº›å ´æ™¯ä¸­ï¼Œæˆ‘å€‘å¸Œæœ›é€™äº›å€¼å­˜åœ¨æ–¼å †æ£§ä¸­ï¼Œç”šè‡³å­˜åœ¨æ–¼ç¡¬ä»¶å¯„å­˜å™¨ä¸­ã€‚å› æ­¤ï¼ŒMojo çµæ§‹ç¸½æ˜¯å…§è¯åˆ°å…¶å®¹å™¨ä¸­ï¼Œç„¡è«–æ˜¯ä½œç‚ºå¦ä¸€ç¨®é¡å‹çš„å­—æ®µé‚„æ˜¯åŒ…å«å‡½æ•¸çš„å †æ£§å¹€ã€‚
é€™æå‡ºäº†ä¸€äº›æœ‰è¶£çš„å•é¡Œï¼šå¦‚ä½•å¯¦ç¾éœ€è¦æ”¹è®Šselfçµæ§‹é¡å‹çš„æ–¹æ³•ï¼Œä¾‹å¦‚__iadd__ï¼Ÿå®ƒæ˜¯å¦‚ä½•letå·¥ä½œçš„ä»¥åŠå¦‚ä½•é˜²æ­¢çªè®Šï¼Ÿå¦‚ä½•æ§åˆ¶é€™äº›å€¼çš„ç”Ÿå‘½é€±æœŸä»¥ä½¿ Mojo æˆç‚ºå…§å­˜å®‰å…¨çš„èªè¨€ï¼Ÿ
ç­”æ¡ˆæ˜¯ï¼ŒMojo ç·¨è­¯å™¨ä½¿ç”¨æ•¸æ“šæµåˆ†æå’Œé¡å‹è¨»é‡‹ä¾†æä¾›å°å€¼å‰¯æœ¬ã€å¼•ç”¨åˆ¥åå’Œçªè®Šæ§åˆ¶çš„å®Œå…¨æ§åˆ¶ã€‚é€™äº›åŠŸèƒ½åœ¨å¾ˆå¤šæ–¹é¢èˆ‡ Rust èªè¨€ä¸­çš„åŠŸèƒ½ç›¸ä¼¼ï¼Œä½†å®ƒå€‘çš„å·¥ä½œæ–¹å¼æœ‰æ‰€ä¸åŒï¼Œä»¥ä¾¿ä½¿ Mojo æ›´å®¹æ˜“å­¸ç¿’ï¼Œä¸¦ä¸”å®ƒå€‘å¯ä»¥æ›´å¥½åœ°é›†æˆåˆ° Python ç”Ÿæ…‹ç³»çµ±ä¸­ï¼Œè€Œä¸éœ€è¦å¤§é‡çš„è¨»é‡‹è² æ“”ã€‚
åœ¨ä»¥ä¸‹éƒ¨åˆ†ä¸­ï¼Œæ‚¨å°‡äº†è§£å¦‚ä½•æ§åˆ¶å‚³éåˆ° Mojofnå‡½æ•¸çš„å°è±¡çš„å…§å­˜æ‰€æœ‰æ¬Šã€‚
ä¸å¯è®Šåƒæ•¸ ( borrowed)
å€Ÿç”¨å°åƒæ˜¯å°å‡½æ•¸æ¥æ”¶çš„å°è±¡çš„ä¸å¯è®Šå¼•ç”¨ï¼Œè€Œä¸æ˜¯æ¥æ”¶è©²å°è±¡çš„å‰¯æœ¬ã€‚å› æ­¤ï¼Œè¢«èª¿ç”¨å‡½æ•¸å…·æœ‰å°è©²å°è±¡çš„å®Œå…¨è®€å–å’ŒåŸ·è¡Œè¨ªå•æ¬Šé™ï¼Œä½†ç„¡æ³•ä¿®æ”¹å®ƒï¼ˆèª¿ç”¨è€…ä»ç„¶æ“æœ‰è©²å°è±¡çš„ç¨å â€œæ‰€æœ‰æ¬Šâ€ï¼‰ã€‚
ä¾‹å¦‚ï¼Œè€ƒæ…®é€™å€‹çµæ§‹ï¼Œæˆ‘å€‘åœ¨å‚³éå®ƒçš„å¯¦ä¾‹æ™‚ä¸æƒ³è¤‡è£½å®ƒï¼š
```mojo
# Don't worry about this code yet. It's just needed for the function below.
# It's a type so expensive to copy around so it does not have a
# __copyinit__ method.
struct SomethingBig:
    var id_number: Int
    var huge: HeapArray
    fn __init__(inout self, id: Int):
        self.huge = HeapArray(1000, 0)
        self.id_number = id

    # self is passed by-reference for mutation as described above.
    fn set_id(inout self, number: Int):
        self.id_number = number

    # Arguments like self are passed as borrowed by default.
    fn print_id(self):  # Same as: fn print_id(borrowed self):
        print(self.id_number)
```
ç•¶å°‡ çš„å¯¦ä¾‹å‚³éSomethingBigçµ¦å‡½æ•¸æ™‚ï¼Œæœ‰å¿…è¦å‚³éå¼•ç”¨ï¼Œå› ç‚ºSomethingBigç„¡æ³•è¤‡è£½ï¼ˆå®ƒæ²’æœ‰__copyinit__æ–¹æ³•ï¼‰ã€‚ä¸¦ä¸”ï¼Œå¦‚ä¸Šæ‰€è¿°ï¼Œfné»˜èªæƒ…æ³ä¸‹åƒæ•¸æ˜¯ä¸å¯è®Šå¼•ç”¨ï¼Œä½†æ‚¨å¯ä»¥ä½¿ç”¨borrowedé—œéµå­—é¡¯å¼å®šç¾©å®ƒï¼Œå¦‚æ­¤è™•å‡½æ•¸æ‰€ç¤ºuse_something_big()ï¼š
```mojo
fn use_something_big(borrowed a: SomethingBig, b: SomethingBig):
    """'a' and 'b' are both immutable, because 'borrowed' is the default."""
    a.print_id()
    b.print_id()

let a = SomethingBig(10)
let b = SomethingBig(20)
use_something_big(a, b)

""" =>
10
20
"""
```
æ­¤é»˜èªå€¼çµ±ä¸€é©ç”¨æ–¼æ‰€æœ‰åƒæ•¸ï¼ŒåŒ…æ‹¬selfæ–¹æ³•çš„åƒæ•¸ã€‚ç•¶å‚³éå¤§å€¼æˆ–å‚³éæ˜‚è²´çš„å€¼ï¼ˆå¦‚å¼•ç”¨è¨ˆæ•¸æŒ‡é‡ï¼‰ï¼ˆé€™æ˜¯ Python/Mojo é¡çš„é»˜èªå€¼ï¼‰æ™‚ï¼Œé€™æœƒæ›´æœ‰æ•ˆï¼Œå› ç‚ºå‚³éåƒæ•¸æ™‚ä¸å¿…èª¿ç”¨è¤‡åˆ¶æ§‹é€ å‡½æ•¸å’Œææ§‹å‡½æ•¸ã€‚
å› ç‚ºå‡½æ•¸çš„é»˜èªåƒæ•¸ç´„å®šfnæ˜¯borrowedï¼Œæ‰€ä»¥ Mojo å…·æœ‰ç°¡å–®ä¸”ç¬¦åˆé‚è¼¯çš„ä»£ç¢¼ï¼Œé»˜èªæƒ…æ³ä¸‹å¯ä»¥åŸ·è¡Œæ­£ç¢ºçš„æ“ä½œã€‚ä¾‹å¦‚ï¼Œæˆ‘å€‘ä¸æƒ³åƒ…åƒ…SomethingBigç‚ºäº†èª¿ç”¨print_id()æ–¹æ³•æˆ–èª¿ç”¨use_something_big().
é€™ç¨®å€Ÿç”¨åƒæ•¸ç´„å®šåœ¨æŸäº›æ–¹éºµé¡ä¼¼æ–¼ C++ ä¸­çš„åƒæ•¸å‚³éconst&ï¼Œé€™é¿å…äº†å€¼çš„å‰¯æœ¬ä¸¦ç¦ç”¨è¢«èª¿ç”¨è€…ä¸­çš„å¯è®Šæ€§ã€‚ç„¶è€Œï¼Œå€Ÿç”¨çš„ç´„å®šconst&åœ¨å…©å€‹é‡è¦æ–¹é¢èˆ‡ C++ æœ‰æ‰€ä¸åŒï¼š
Mojo ç·¨è­¯å™¨å¯¦ç¾äº†ä¸€å€‹å€Ÿç”¨æª¢æŸ¥å™¨ï¼ˆé¡ä¼¼æ–¼ Rustï¼‰ï¼Œè©²æª¢æŸ¥å™¨å¯ä»¥é˜²æ­¢ä»£ç¢¼åœ¨å­˜åœ¨æœªå®Œæˆçš„ä¸å¯è®Šå¼•ç”¨æ™‚å‹•æ…‹å½¢æˆå°æŸå€‹å€¼çš„å¯è®Šå¼•ç”¨ï¼Œä¸¦ä¸”å®ƒå¯ä»¥é˜²æ­¢å°åŒä¸€å€¼é€²è¡Œå¤šå€‹å¯è®Šå¼•ç”¨ã€‚æ‚¨å¯ä»¥é€²è¡Œå¤šæ¬¡å€Ÿç”¨ï¼ˆå¦‚use_something_bigä¸Šé¢çš„èª¿ç”¨æ‰€ç¤ºï¼‰ï¼Œä½†ä¸èƒ½é€šéå¯è®Šå¼•ç”¨å‚³éæŸäº›å…§å®¹ä¸¦åŒæ™‚è—‰ç”¨ã€‚ï¼ˆTODOï¼šç•¶å‰æœªå•Ÿç”¨ï¼‰ã€‚
Intåƒã€Floatã€ å’Œ é€™æ¨£çš„å°å€¼SIMDç›´æ¥åœ¨æ©Ÿå™¨å¯„å­˜å™¨ä¸­å‚³éï¼Œè€Œä¸æ˜¯é€šéé¡å¤–çš„é–“æ¥å‚³éï¼ˆé€™æ˜¯å› ç‚ºå®ƒå€‘æ˜¯ç”¨è£é£¾@register_passableå™¨è²æ˜çš„ï¼‰ã€‚èˆ‡ C++ å’Œ Rust ç­‰èªè¨€ç›¸æ¯”ï¼Œé€™æ˜¯ä¸€å€‹é¡¯è‘—çš„æ€§èƒ½å¢å¼·ï¼Œä¸¦å°‡é€™ç¨®å„ªåŒ–å¾æ¯å€‹èª¿ç”¨ç«™é»è½‰ç§»åˆ°å°é¡å‹é€²è¡Œè²æ˜ã€‚
èˆ‡ Rust é¡ä¼¼ï¼ŒMojo çš„å€Ÿç”¨æª¢æŸ¥å™¨å¼·åˆ¶åŸ·è¡Œä¸è®Šé‡çš„æ’ä»–æ€§ã€‚Rust å’Œ Mojo ä¹‹é–“çš„ä¸»è¦å€åˆ¥åœ¨æ–¼ï¼ŒMojo ä¸éœ€è¦èª¿ç”¨æ–¹æœ‰ä¸€å€‹å°è¨˜ä¾†å‚³éå€Ÿç”¨ã€‚æ­¤å¤–ï¼ŒMojo åœ¨å‚³éå°å€¼æ™‚æ•ˆç‡æ›´é«˜ï¼Œè€Œ Rust é»˜èªç§»å‹•å€¼è€Œä¸æ˜¯é€šéå€Ÿç”¨å‚³éå®ƒå€‘ã€‚é€™äº›ç­–ç•¥å’Œèªæ³•æ±ºç­–ä½¿ Mojo èƒ½å¤ æä¾›æ›´æ˜“æ–¼ä½¿ç”¨çš„ç·¨ç¨‹æ¨¡å‹ã€‚
å¯è®Šåƒæ•¸ ( inout)
å¦ä¸€æ–¹é¢ï¼Œå¦‚æœæ‚¨å®šç¾©ä¸€å€‹fnå‡½æ•¸ä¸¦å¸Œæœ›åƒæ•¸å¯è®Šï¼Œå‰‡å¿…é ˆä½¿ç”¨é—œéµå­—å°‡åƒæ•¸è²æ˜ç‚ºå¯è®Šçš„inoutã€‚
æç¤ºï¼šç•¶æ‚¨çœ‹åˆ° æ™‚inoutï¼Œé€™æ„å‘³è‘—å°å‡½æ•¸å…§éƒ¨åƒæ•¸æ‰€åšçš„ä»»ä½•æ›´æ”¹åœ¨å‡½æ•¸å¤–éƒ¨éƒ½æ˜¯å¯è¦‹çš„ã€‚
è€ƒæ…®ä»¥ä¸‹ç¤ºä¾‹ï¼Œå…¶ä¸­__iadd__å‡½æ•¸ï¼ˆå¯¦ç¾å°±åœ°æ·»åŠ æ“ä½œï¼Œä¾‹å¦‚x += 2ï¼‰å˜—è©¦ä¿®æ”¹selfï¼š
```mojo
struct MyInt:
    var value: Int
    fn __init__(inout self, v: Int):
        self.value = v

    fn __copyinit__(inout self, other: MyInt):
        self.value = other.value

    # self and rhs are both immutable in __add__.
    fn __add__(self, rhs: MyInt) -> MyInt:
        return MyInt(self.value + rhs.value)

    # ... but this cannot work for __iadd__
    # Uncomment to see the error:
    #fn __iadd__(self, rhs: Int):
    #    self = self + rhs  # ERROR: cannot assign to self!
```

å¦‚æœå–æ¶ˆè¨»é‡‹è©²__iadd__()æ–¹æ³•ï¼Œæ‚¨å°‡æ”¶åˆ°ç·¨è­¯å™¨éŒ¯èª¤ã€‚

é€™è£¡çš„å•é¡Œæ˜¯ æ˜¯selfä¸å¯è®Šçš„ï¼Œå› ç‚ºé€™æ˜¯ä¸€å€‹ Mojofnå‡½æ•¸ï¼Œæ‰€ä»¥å®ƒä¸èƒ½æ”¹è®Šåƒæ•¸çš„å…§éƒ¨ç‹€æ…‹ï¼ˆé»˜èªåƒæ•¸ç´„å®šæ˜¯borrowedï¼‰ã€‚inoutè§£æ±ºæ–¹æ¡ˆæ˜¯é€šéåœ¨åƒæ•¸åç¨±ä¸Šæ·»åŠ é—œéµå­—ä¾†è²æ˜åƒæ•¸æ˜¯å¯è®Šçš„selfï¼š

```mojo
struct MyInt:
    var value: Int

    fn __init__(inout self, v: Int):
        self.value = v

    fn __copyinit__(inout self, other: MyInt):
        self.value = other.value

    # self and rhs are both immutable in __add__.
    fn __add__(self, rhs: MyInt) -> MyInt:
        return MyInt(self.value + rhs.value)

    # ... now this works:
    fn __iadd__(inout self, rhs: Int):
        self = self + rhs
```

ç¾åœ¨selfåƒæ•¸åœ¨å‡½æ•¸ä¸­æ˜¯å¯è®Šçš„ï¼Œä¸¦ä¸”ä»»ä½•æ›´æ”¹åœ¨èª¿ç”¨è€…ä¸­éƒ½æ˜¯å¯è¦‹çš„ï¼Œå› æ­¤æˆ‘å€‘å¯ä»¥ä½¿ç”¨ä»¥ä¸‹å‘½ä»¤åŸ·è¡Œå°±åœ°åŠ æ³•MyIntï¼š
```mojo
var x: MyInt = 42
x += 1
print(x.value) # prints 43 as expected

# However...
let y = x
# Uncomment to see the error:
# y += 1       # ERROR: Cannot mutate 'let' value


# => 43
```

å¦‚æœå–æ¶ˆè¨»é‡‹ä¸Šé¢çš„æœ€å¾Œä¸€è¡Œï¼Œå‰‡letå€¼çš„çªè®Šæœƒå¤±æ•—ï¼Œå› ç‚ºä¸å¯èƒ½å½¢æˆå°ä¸å¯è®Šå€¼çš„å¯è®Šå¼•ç”¨ï¼ˆletä½¿è®Šé‡ä¸å¯è®Šï¼‰ã€‚

ç•¶ç„¶ï¼Œæ‚¨å¯ä»¥è²æ˜å¤šå€‹inoutåƒæ•¸ã€‚ä¾‹å¦‚ï¼Œæ‚¨å¯ä»¥åƒé€™æ¨£å®šç¾©å’Œä½¿ç”¨äº¤æ›å‡½æ•¸ï¼š
```mojo
fn swap(inout lhs: Int, inout rhs: Int):
    let tmp = lhs
    lhs = rhs
    rhs = tmp

var x = 42
var y = 12
print(x, y)  # Prints 42, 12
swap(x, y)
print(x, y)  # Prints 12, 42
"""=>
42 12
12 42
"""
```
è©²ç³»çµ±çš„ä¸€å€‹éå¸¸é‡è¦çš„æ–¹é¢æ˜¯å®ƒçš„æ‰€æœ‰çµ„æˆéƒ½æ˜¯æ­£ç¢ºçš„ã€‚

è«‹æ³¨æ„ï¼Œæˆ‘å€‘ä¸å°‡æ­¤åƒæ•¸ç¨±ç‚ºâ€œé€šéå¼•ç”¨â€å‚³éã€‚å„˜ç®¡inoutç´„å®šåœ¨æ¦‚å¿µä¸Šæ˜¯ç›¸åŒçš„ï¼Œä½†æˆ‘å€‘ä¸å°‡å…¶ç¨±ç‚ºæŒ‰å¼•ç”¨å‚³éï¼Œå› ç‚ºå¯¦ç¾å¯¦éš›ä¸Šå¯èƒ½ä½¿ç”¨æŒ‡é‡å‚³éå€¼ã€‚

å‚³éåƒæ•¸ (ownedå’Œ^)
Mojo æ”¯æŒçš„æœ€å¾Œä¸€å€‹åƒæ•¸ç´„å®šæ˜¯ownedåƒæ•¸ç´„å®šã€‚æ­¤ç´„å®šç”¨æ–¼æƒ³è¦ç²å¾—å€¼çš„ç¨å æ‰€æœ‰æ¬Šçš„å‡½æ•¸ï¼Œä¸¦ä¸”é€šå¸¸èˆ‡å¾Œç¶´é‹ç®—^ç¬¦ä¸€èµ·ä½¿ç”¨ã€‚

ä¾‹å¦‚ï¼Œå‡è¨­æ‚¨æ­£åœ¨ä½¿ç”¨åƒ…ç§»å‹•é¡å‹ï¼Œä¾‹å¦‚å”¯ä¸€æŒ‡é‡ï¼š
```mojo
# This is not really a unique pointer, we just model its behavior here
# to serve the examples below.
struct UniquePointer:
    var ptr: Int

    fn __init__(inout self, ptr: Int):
        self.ptr = ptr

    fn __moveinit__(inout self, owned existing: Self):
        self.ptr = existing.ptr

    fn __del__(owned self):
        self.ptr = 0
```

é›–ç„¶è©²borrowç´„å®šä½¿å¾—ç„¡éœ€å„€å¼å³å¯è¼•é¬†ä½¿ç”¨é€™å€‹ç¨ç‰¹çš„æŒ‡é‡ï¼Œä½†åœ¨æŸäº›æ™‚å€™æ‚¨å¯èƒ½å¸Œæœ›å°‡æ‰€æœ‰æ¬Šè½‰ç§»çµ¦æŸäº›å…¶ä»–å‡½æ•¸ã€‚åœ¨é€™ç¨®æƒ…æ³ä¸‹ï¼Œæ‚¨éœ€è¦^å°æ´»å­—å°åˆ·è¡“ä½¿ç”¨â€œå‚³è¼¸â€æ“ä½œç¬¦ã€‚

é‹ç®—^ç¬¦çµæŸå€¼ç¶å®šçš„ç”Ÿå‘½é€±æœŸï¼Œä¸¦å°‡å€¼æ‰€æœ‰æ¬Šè½‰ç§»çµ¦å…¶ä»–æ±è¥¿ï¼ˆåœ¨ä¸‹é¢çš„ç¤ºä¾‹ä¸­ï¼Œæ‰€æœ‰æ¬Šè½‰ç§»çµ¦å‡½æ•¸take_ptr()ï¼‰ã€‚ç‚ºäº†æ”¯æŒé€™ä¸€é»ï¼Œæ‚¨å¯ä»¥å°‡å‡½æ•¸å®šç¾©ç‚ºæ¥å—ownedåƒæ•¸ã€‚ä¾‹å¦‚ï¼Œæ‚¨å¯ä»¥å®šç¾©take_ptr()ç²å–åƒæ•¸çš„æ‰€æœ‰æ¬Šï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼š

fn take_ptr(owned p: UniquePointer):
    print("take_ptr")
    print(p.ptr)

fn use_ptr(borrowed p: UniquePointer):
    print("use_ptr")
    print(p.ptr)

fn work_with_unique_ptrs():
    let p = UniquePointer(100)
    use_ptr(p)    # Pass to borrowing function.
    take_ptr(p^)  # Pass ownership of the `p` value to another function.

    # Uncomment to see an error:
    # use_ptr(p) # ERROR: p is no longer valid here!

work_with_unique_ptrs()

use_ptr
100
take_ptr
100
è«‹æ³¨æ„ï¼Œå¦‚æœå–æ¶ˆå°ç¬¬äºŒæ¬¡èª¿ç”¨çš„è¨»é‡‹use_ptr()ï¼Œå‰‡æœƒæ”¶åˆ°éŒ¯èª¤ï¼Œå› ç‚ºè©²på€¼å·²å‚³è¼¸åˆ°è©²take_ptr()å‡½æ•¸ï¼Œå› æ­¤è©²på€¼è¢«éŠ·æ¯€ã€‚

å› ç‚ºå®ƒå·²è¢«è²æ˜ownedï¼Œæ‰€ä»¥è©²take_ptr()å‡½æ•¸çŸ¥é“å®ƒå…·æœ‰å°è©²å€¼çš„å”¯ä¸€è¨ªå•æ¬Šã€‚é€™å°æ–¼è«¸å¦‚å”¯ä¸€æŒ‡é‡ä¹‹é¡çš„äº‹æƒ…éå¸¸é‡è¦ï¼Œä¸¦ä¸”ç•¶æ‚¨æƒ³è¦é¿å…è¤‡è£½æ™‚å®ƒå¾ˆæœ‰ç”¨ã€‚

ä¾‹å¦‚ï¼Œæ‚¨å°‡ç‰¹åˆ¥çœ‹åˆ°ownedé—œæ–¼ææ§‹å‡½æ•¸å’Œæ¶ˆè€—ç§»å‹•åˆå§‹å€¼è¨­å®šé …çš„ç´„å®šã€‚ä¾‹å¦‚ï¼Œæˆ‘å€‘ä¹‹å‰å®šç¾©çš„çµæ§‹é«”åœ¨å…¶æ–¹æ³•ä¸­HeapArrayä½¿ç”¨ï¼Œå› ç‚ºæ‚¨éœ€è¦æ“æœ‰ä¸€å€‹å€¼æ‰èƒ½éŠ·æ¯€å®ƒï¼ˆæˆ–è€…åœ¨ç§»å‹•æ§‹é€ å‡½æ•¸çš„æƒ…æ³ä¸‹ç«Šå–å…¶éƒ¨åˆ†ï¼‰ã€‚owned__del__()

æ¯”è¼ƒdefå’Œfnåƒæ•¸å‚³é
Mojo çš„defå‡½æ•¸æœ¬è³ªä¸Šåªæ˜¯ç‚ºfnå‡½æ•¸åŠ ç³–ï¼š

æ²’æœ‰é¡¯å¼é¡å‹è¨»é‡‹çš„åƒæ•¸defé»˜èªç‚ºObject.

defæ²’æœ‰ç´„å®šé—œéµå­—ï¼ˆä¾‹å¦‚inoutor ï¼‰çš„åƒæ•¸ownedé€šééš±å¼è¤‡åˆ¶å‚³éåˆ°èˆ‡åƒæ•¸åŒåçš„å¯è®Šè®Šé‡ä¸­ã€‚ï¼ˆé€™è¦æ±‚è©²é¡å‹æœ‰ä¸€å€‹__copyinit__æ–¹æ³•ã€‚ï¼‰

ä¾‹å¦‚ï¼Œé€™å…©å€‹å‡½æ•¸å…·æœ‰ç›¸åŒçš„è¡Œç‚ºï¼š

def example(inout a: Int, b: Int, c):
    # b and c use value semantics so they're mutable in the function
    ...

fn example(inout a: Int, b_in: Int, c_in: Object):
    # b_in and c_in are immutable references, so we make mutable shadow copies
    var b = b_in
    var c = c_in
    ...

å·å½±å‰¯æœ¬é€šå¸¸ä¸æœƒå¢åŠ é–‹éŠ·ï¼Œå› ç‚ºåƒé€™æ¨£çš„å°é¡å‹çš„å¼•ç”¨Objectè¤‡åˆ¶èµ·ä¾†å¾ˆä¾¿å®œã€‚æ˜‚è²´çš„éƒ¨åˆ†æ˜¯èª¿æ•´å¼•ç”¨è¨ˆæ•¸ï¼Œä½†é€™å¯ä»¥é€šéç§»å‹•å„ªåŒ–ä¾†æ¶ˆé™¤ã€‚

Pythoné›†æˆ
åœ¨ Mojo ä¸­ä½¿ç”¨æ‚¨ç†Ÿæ‚‰å’Œå–œæ„›çš„ Python æ¨¡å¡Šéå¸¸ç°¡å–®ã€‚æ‚¨å¯ä»¥å°‡ä»»ä½• Python æ¨¡å¡Šå°å…¥åˆ° Mojo ç¨‹åºä¸­ï¼Œä¸¦å¾ Mojo é¡å‹å‰µå»º Python é¡å‹ã€‚

å°å…¥Pythonæ¨¡å¡Š
è¦åœ¨ Mojo ä¸­å°å…¥ Python æ¨¡å¡Šï¼Œåªéœ€Python.import_module()ä½¿ç”¨æ¨¡å¡Šåç¨±é€²è¡Œèª¿ç”¨ï¼š

from PythonInterface import Python

# This is equivalent to Python's `import numpy as np`
let np = Python.import_module("numpy")

# Now use numpy as if writing in Python
array = np.array([1, 2, 3])
print(array)

[1 2 3]
æ˜¯çš„ï¼Œé€™æœƒå°å…¥ Python NumPyï¼Œä¸¦ä¸”æ‚¨å¯ä»¥å°å…¥ä»»ä½•å…¶ä»– Python æ¨¡å¡Šã€‚

ç›®å‰ï¼Œæ‚¨ç„¡æ³•å°å…¥å–®å€‹æˆå“¡ï¼ˆä¾‹å¦‚å–®å€‹ Python é¡æˆ–å‡½æ•¸ï¼‰ï¼Œæ‚¨å¿…é ˆå°å…¥æ•´å€‹ Python æ¨¡å¡Šï¼Œç„¶å¾Œé€šéæ¨¡å¡Šåç¨±è¨ªå•æˆå“¡ã€‚

Python ä¸­çš„ Mojo é¡å‹
Mojo åŸå§‹é¡å‹éš±å¼è½‰æ›ç‚º Python å°è±¡ã€‚ä»Šå¤©ï¼Œæˆ‘å€‘æ”¯æŒåˆ—è¡¨ã€å…ƒçµ„ã€æ•´æ•¸ã€æµ®é»æ•¸ã€å¸ƒçˆ¾å€¼å’Œå­—ç¬¦ä¸²ã€‚

ä¾‹å¦‚ï¼Œçµ¦å®šé€™å€‹æ‰“å° Python é¡å‹çš„ Python å‡½æ•¸ï¼š

%%python
def type_printer(my_list, my_tuple, my_int, my_string, my_float):
    print(type(my_list))
    print(type(my_tuple))
    print(type(my_int))
    print(type(my_string))
    print(type(my_float))

æ‚¨å¯ä»¥æ¯«ç„¡å•é¡Œåœ°å‚³é Python å‡½æ•¸ Mojo é¡å‹ï¼š

type_printer([0, 3], (False, True), 4, "orange", 3.4)

<class 'list'>
<class 'tuple'>
<class 'int'>
<class 'str'>
<class 'float'>
è«‹æ³¨æ„ï¼Œåœ¨ Jupyter ç­†è¨˜æœ¬ä¸­ï¼Œä¸Šé¢è²æ˜çš„ Python å‡½æ•¸å¯è‡ªå‹•ä¾›ä»¥ä¸‹ä»£ç¢¼å–®å…ƒä¸­çš„ä»»ä½• Mojo ä»£ç¢¼ä½¿ç”¨ã€‚

Mojo é‚„æ²’æœ‰æ¨™æº–å­—å…¸ï¼Œå› æ­¤é‚„ç„¡æ³•å¾ Mojo å­—å…¸å‰µå»º Python å­—å…¸ã€‚ä¸éï¼Œæ‚¨å¯ä»¥åœ¨ Mojo ä¸­ä½¿ç”¨ Python å­—å…¸ï¼è¦å‰µå»º Python å­—å…¸ï¼Œè«‹ä½¿ç”¨ä»¥ä¸‹dictæ–¹æ³•ï¼š

from PythonInterface import Python
from PythonObject import PythonObject
from IO import print
from Range import range

var dictionary = Python.dict()
dictionary["fruit"] = "apple"
dictionary["starch"] = "potato"

var keys: PythonObject = ["fruit", "starch", "protein"]
var N: Int = keys.__len__().__index__()
print(N, "items")

for i in range(N):
    if Python.is_type(dictionary.get(keys[i]), Python.none()):
        print(keys[i], "is not in dictionary")
    else:
        print(keys[i], "is included")

3 items
fruit is included
starch is included
protein is not in dictionary
å°å…¥æœ¬åœ°Pythonæ¨¡å¡Š
å¦‚æœæ‚¨æƒ³åœ¨ Mojo ä¸­ä½¿ç”¨ä¸€äº›æœ¬åœ° Python ä»£ç¢¼ï¼Œåªéœ€å°‡ç›®éŒ„æ·»åŠ åˆ° Python è·¯å¾‘ï¼Œç„¶å¾Œå°å…¥æ¨¡å¡Šå³å¯ã€‚

ä¾‹å¦‚ï¼Œå‡è¨­æ‚¨æœ‰ä¸€å€‹åç‚ºçš„ Python æ–‡ä»¶mypython.pyï¼š

import numpy as np

def my_algorithm(a, b):
    array_a = np.random.rand(a, a)
    return array_a + b

ä»¥ä¸‹æ˜¯å°å…¥å®ƒä¸¦åœ¨ Mojo æ–‡ä»¶ä¸­ä½¿ç”¨å®ƒçš„æ–¹æ³•ï¼š

from PythonInterface import Python

Python.add_to_path("path/to/module")
let mypython = Python.import_module("mypython")

let c = mypython.my_algorithm(2, 3)
print(c)

åœ¨ Mojo ä¸­ä½¿ç”¨ Python æ™‚ç„¡éœ€æ“”å¿ƒå…§å­˜ç®¡ç†å•é¡Œã€‚ä¸€åˆ‡éƒ½æ­£å¸¸ï¼Œå› ç‚º Mojo å¾ä¸€é–‹å§‹å°±æ˜¯ç‚º Python è¨­è¨ˆçš„ã€‚

åƒæ•¸åŒ–ï¼šç·¨è­¯æ™‚å…ƒç·¨ç¨‹
Python æœ€ä»¤äººé©šå¥‡çš„åŠŸèƒ½ä¹‹ä¸€æ˜¯å…¶å¯æ“´å±•çš„é‹è¡Œæ™‚å…ƒç·¨ç¨‹åŠŸèƒ½ã€‚é€™ä½¿å¾—å»£æ³›çš„åº«æˆç‚ºå¯èƒ½ï¼Œä¸¦æä¾›äº†éˆæ´»ä¸”å¯æ“´å±•çš„ç·¨ç¨‹æ¨¡å‹ï¼Œä¸–ç•Œå„åœ°çš„ Python ç¨‹åºå“¡éƒ½å¯ä»¥å¾ä¸­å—ç›Šã€‚ä¸å¹¸çš„æ˜¯ï¼Œé€™äº›åŠŸèƒ½ä¹Ÿæ˜¯æœ‰ä»£åƒ¹çš„ï¼šå› ç‚ºå®ƒå€‘æ˜¯åœ¨é‹è¡Œæ™‚è©•ä¼°çš„ï¼Œæ‰€ä»¥å®ƒå€‘ç›´æ¥å½±éŸ¿åº•å±¤ä»£ç¢¼çš„é‹è¡Œæ™‚æ•ˆç‡ã€‚ç”±æ–¼ IDE ä¸çŸ¥é“å®ƒå€‘ï¼Œå› æ­¤ä»£ç¢¼å®Œæˆç­‰ IDE åŠŸèƒ½å¾ˆé›£ç†è§£å®ƒå€‘ä¸¦ä½¿ç”¨å®ƒå€‘ä¾†æ”¹å–„é–‹ç™¼äººå“¡é«”é©—ã€‚

åœ¨Pythonç”Ÿæ…‹ç³»çµ±ä¹‹å¤–ï¼Œéœæ…‹å…ƒç·¨ç¨‹ä¹Ÿæ˜¯é–‹ç™¼çš„é‡è¦çµ„æˆéƒ¨åˆ†ï¼Œå¯ä»¥é–‹ç™¼æ–°çš„ç·¨ç¨‹ç¯„ä¾‹å’Œé«˜ç´šåº«ã€‚é€™å€‹é ˜åŸŸæœ‰è¨±å¤šç¾æœ‰æŠ€è¡“çš„ä¾‹å­ï¼Œå…·æœ‰ä¸åŒçš„æ¬Šè¡¡ï¼Œä¾‹å¦‚ï¼š

é è™•ç†å™¨ï¼ˆä¾‹å¦‚C é è™•ç†å™¨ã€Lex/YACC ç­‰ï¼‰å¯èƒ½æ˜¯æœ€ç¹é‡çš„ã€‚å®ƒå€‘å®Œå…¨é€šç”¨ï¼Œä½†åœ¨é–‹ç™¼äººå“¡é«”é©—å’Œå·¥å…·é›†æˆæ–¹é¢æœ€å·®ã€‚

ä¸€äº›èªè¨€ï¼ˆå¦‚ Lisp å’Œ Rustï¼‰æ”¯æŒï¼ˆæœ‰æ™‚æ˜¯â€œè¡›ç”Ÿçš„â€ï¼‰å®æ“´å±•åŠŸèƒ½ï¼Œé€šéæ›´å¥½çš„å·¥å…·é›†æˆå¯¦ç¾èªæ³•æ“´å±•å’Œæ ·æ¿æ–‡ä»¶æ¸›å°‘ã€‚

ä¸€äº›è¼ƒèˆŠçš„èªè¨€ï¼ˆä¾‹å¦‚ C++ï¼‰å…·æœ‰éå¸¸é¾å¤§ä¸”è¤‡é›œçš„å…ƒç·¨ç¨‹èªè¨€ï¼ˆæ¨¡æ¿ï¼‰ï¼Œå®ƒå€‘æ˜¯é‹è¡Œæ™‚èªè¨€çš„é›™é‡èªè¨€ã€‚é€™äº›å°¤å…¶é›£ä»¥å­¸ç¿’ï¼Œä¸¦ä¸”ç·¨è­¯æ™‚é–“å’ŒéŒ¯èª¤æ¶ˆæ¯éƒ½å¾ˆå·®ã€‚

æœ‰äº›èªè¨€ï¼ˆå¦‚ Swiftï¼‰ä»¥ä¸€æµçš„æ–¹å¼å°‡è¨±å¤šåŠŸèƒ½æ§‹å»ºåˆ°æ ¸å¿ƒèªè¨€ä¸­ï¼Œç‚ºå¸¸è¦‹æƒ…æ³æä¾›è‰¯å¥½çš„äººé«”å·¥ç¨‹å­¸æ•ˆæœï¼Œä½†çŠ§ç‰²äº†é€šç”¨æ€§ã€‚

ä¸€äº›è¼ƒæ–°çš„èªè¨€ï¼ˆä¾‹å¦‚ Zigï¼‰å°‡èªè¨€è§£é‡‹å™¨é›†æˆåˆ°ç·¨è­¯æµç¨‹ä¸­ï¼Œä¸¦å…è¨±è§£é‡‹å™¨åœ¨ç·¨è­¯ AST æ™‚é€²è¡Œåæ˜ ã€‚é€™ä½¿å¾—è¨±å¤šèˆ‡å®ç³»çµ±ç›¸åŒçš„åŠŸèƒ½å…·æœ‰æ›´å¥½çš„æ“´å±•æ€§å’Œé€šç”¨æ€§ã€‚

å°æ–¼ Modular åœ¨äººå·¥æ™ºèƒ½ã€é«˜æ€§èƒ½æ©Ÿå™¨å­¸ç¿’å…§æ ¸å’ŒåŠ é€Ÿå™¨æ–¹é¢çš„å·¥ä½œï¼Œæˆ‘å€‘éœ€è¦å…ˆé€²çš„å…ƒç·¨ç¨‹ç³»çµ±æä¾›çš„é«˜æŠ½è±¡èƒ½åŠ›ã€‚æˆ‘å€‘éœ€è¦é«˜ç´šçš„é›¶æˆæœ¬æŠ½è±¡ã€å¯Œæœ‰è¡¨ç¾åŠ›çš„åº«ä»¥åŠå¤šç¨®ç®—æ³•è®Šé«”çš„å¤§è¦æ¨¡é›†æˆã€‚æˆ‘å€‘å¸Œæœ›åº«é–‹ç™¼äººå“¡èƒ½å¤ æ“´å±•ç³»çµ±ï¼Œå°±åƒä»–å€‘åœ¨ Python ä¸­æ‰€åšçš„é‚£æ¨£ï¼Œæä¾›ä¸€å€‹å¯æ“´å±•çš„é–‹ç™¼å¹³å°ã€‚

ä¹Ÿå°±æ˜¯èªªï¼Œæˆ‘å€‘ä¸é¡˜æ„çŠ§ç‰²é–‹ç™¼äººå“¡é«”é©—ï¼ˆâ€‹â€‹åŒ…æ‹¬ç·¨è­¯æ™‚é–“å’ŒéŒ¯èª¤æ¶ˆæ¯ï¼‰ï¼Œä¹Ÿæ²’æœ‰èˆˆè¶£æ§‹å»ºé›£ä»¥æ•™æˆçš„ä¸¦è¡Œèªè¨€ç”Ÿæ…‹ç³»çµ±ã€‚æˆ‘å€‘å¯ä»¥å‘é€™äº›ä»¥å‰çš„ç³»çµ±å­¸ç¿’ï¼Œä½†ä¹Ÿå¯ä»¥åœ¨å…¶åŸºç¤ä¸Šæ§‹å»ºæ–°æŠ€è¡“ï¼ŒåŒ…æ‹¬ MLIR å’Œç´°ç²’åº¦èªè¨€é›†æˆç·©å­˜æŠ€è¡“ã€‚

å› æ­¤ï¼ŒMojo æ”¯æŒç·¨è­¯å™¨ä¸­å…§ç½®çš„ç·¨è­¯æ™‚å…ƒç·¨ç¨‹ï¼Œä½œç‚ºç·¨è­¯çš„ä¸€å€‹å–®ç¨éšæ®µâ€”â€”åœ¨è§£æã€èªç¾©åˆ†æå’Œ IR ç”Ÿæˆä¹‹å¾Œï¼Œä½†åœ¨é™ä½åˆ°ç‰¹å®šæ–¼ç›®æ¨™çš„ä»£ç¢¼ä¹‹å‰ã€‚å®ƒå°é‹è¡Œæ™‚ç¨‹åºä½¿ç”¨èˆ‡å…ƒç¨‹åºç›¸åŒçš„å®¿ä¸»èªè¨€ï¼Œä¸¦åˆ©ç”¨ MLIR ä»¥å¯é æ¸¬çš„æ–¹å¼è¡¨ç¤ºå’Œè©•ä¼°é€™äº›ç¨‹åºã€‚

è®“æˆ‘å€‘çœ‹ä¸€äº›ç°¡å–®çš„ä¾‹å­ã€‚

é—œæ–¼â€œåƒæ•¸â€ï¼š Python é–‹ç™¼äººå“¡å¯ä»¥äº’æ›åœ°ä½¿ç”¨â€œåƒæ•¸â€å’Œâ€œåƒæ•¸â€é€™å…©å€‹è©ä¾†è¡¨ç¤ºâ€œå‚³éåˆ°å‡½æ•¸ä¸­çš„æ±è¥¿â€ã€‚æˆ‘å€‘æ±ºå®šå›æ”¶â€œåƒæ•¸â€å’Œâ€œåƒæ•¸è¡¨é”å¼â€ä¾†è¡¨ç¤º Mojo ä¸­çš„ç·¨è­¯æ™‚å€¼ï¼Œä¸¦ç¹¼çºŒä½¿ç”¨â€œåƒæ•¸â€å’Œâ€œè¡¨é”å¼â€ä¾†å¼•ç”¨é‹è¡Œæ™‚å€¼ã€‚é€™ä½¿æˆ‘å€‘èƒ½å¤ åœç¹â€œåƒæ•¸åŒ–â€å’Œâ€œåƒæ•¸åŒ–â€ç­‰è©é€²è¡Œå°é½Šï¼Œä»¥é€²è¡Œç·¨è­¯æ™‚å…ƒç·¨ç¨‹ã€‚

å®šç¾©åƒæ•¸åŒ–é¡å‹å’Œå‡½æ•¸
æ‚¨å¯ä»¥é€šéåœ¨æ–¹æ‹¬è™Ÿä¸­æŒ‡å®šåƒæ•¸åç¨±å’Œé¡å‹ä¾†åƒæ•¸åŒ–çµæ§‹å’Œå‡½æ•¸ï¼ˆä½¿ç”¨PEP695 èªæ³•çš„æ“´å±•ç‰ˆæœ¬ï¼‰ã€‚èˆ‡åƒæ•¸å€¼ä¸åŒï¼Œåƒæ•¸å€¼åœ¨ç·¨è­¯æ™‚æ˜¯å·²çŸ¥çš„ï¼Œé€™å¯ä»¥å¯¦ç¾é¡å¤–ç´šåˆ¥çš„æŠ½è±¡å’Œä»£ç¢¼é‡ç”¨ï¼Œä»¥åŠè‡ªå‹•èª¿æ•´ç­‰ç·¨è­¯å™¨å„ªåŒ–ã€‚

ä¾‹å¦‚ï¼Œè®“æˆ‘å€‘çœ‹ä¸€ä¸‹SIMDé¡å‹ï¼Œå®ƒè¡¨ç¤ºç¡¬ä»¶ä¸­ä¿å­˜æ¨™é‡æ•¸æ“šé¡å‹çš„å¤šå€‹å¯¦ä¾‹çš„ä½ç´šå‘é‡å¯„å­˜å™¨ã€‚ç¡¬ä»¶åŠ é€Ÿå™¨ä¸æ–·å¼•å…¥æ–°çš„å‘é‡æ•¸æ“šé¡å‹ï¼Œç”šè‡³CPUä¹Ÿå¯èƒ½æœ‰512ä½æˆ–æ›´é•·çš„SIMDå‘é‡ã€‚ç‚ºäº†è¨ªå•é€™äº›è™•ç†å™¨ä¸Šçš„ SIMD æŒ‡ä»¤ï¼Œå¿…é ˆå°‡æ•¸æ“šæ•´å½¢ç‚ºæ­£ç¢ºçš„ SIMD å¯¬åº¦ï¼ˆæ•¸æ“šé¡å‹ï¼‰å’Œé•·åº¦ï¼ˆå‘é‡å¤§å°ï¼‰ã€‚

ç„¶è€Œï¼Œç”¨ Mojo çš„å…§ç½®é¡å‹å®šç¾©æ‰€æœ‰ä¸åŒçš„ SIMD è®Šé«”æ˜¯ä¸å¯è¡Œçš„ã€‚å› æ­¤ï¼ŒMojo çš„SIMDé¡å‹ï¼ˆå®šç¾©ç‚ºçµæ§‹ï¼‰åœ¨å…¶æ–¹æ³•ä¸­å…¬é–‹äº†å¸¸è¦‹çš„ SIMD æ“ä½œï¼Œä¸¦ä½¿ SIMD æ•¸æ“šé¡å‹å’Œå¤§å°å€¼åƒæ•¸åŒ–ã€‚é€™ä½¿æ‚¨å¯ä»¥å°‡æ•¸æ“šç›´æ¥æ˜ å°„åˆ°ä»»ä½•ç¡¬ä»¶ä¸Šçš„ SIMD å‘é‡ã€‚

é€™æ˜¯ Mojo é¡å‹å®šç¾©çš„ç²¾ç°¡ï¼ˆéåŠŸèƒ½ï¼‰ç‰ˆæœ¬SIMDï¼š

struct SIMD[type: DType, size: Int]:
    var value: â€¦ # Some low-level MLIR stuff here

    # Create a new SIMD from a number of scalars
    fn __init__(inout self, *elems: SIMD[type, 1]):  ...

    # Fill a SIMD with a duplicated scalar value.
    @staticmethod
    fn splat(x: SIMD[type, 1]) -> SIMD[type, size]: ...

    # Cast the elements of the SIMD to a different elt type.
    fn cast[target: DType](self) -> SIMD[target, size]: ...

    # Many standard operators are supported.
    fn __add__(self, rhs: Self) -> Self: ...

ä½¿ç”¨åƒæ•¸å®šç¾©æ¯å€‹ SIMD è®Šé«”éå¸¸æœ‰åˆ©æ–¼ä»£ç¢¼é‡ç”¨ï¼Œå› ç‚ºè©²SIMDé¡å‹å¯ä»¥éœæ…‹åœ°è¡¨é”æ‰€æœ‰ä¸åŒçš„å‘é‡è®Šé«”ï¼Œè€Œä¸éœ€è¦èªè¨€é å…ˆå®šç¾©æ¯å€‹è®Šé«”ã€‚

å› ç‚ºSIMDæ˜¯åƒæ•¸åŒ–é¡å‹ï¼Œæ‰€ä»¥selfå…¶å‡½æ•¸ä¸­çš„å¯¦åƒæ”œå¸¶é€™äº›åƒæ•¸â€”â€”å®Œæ•´çš„é¡å‹åç¨±æ˜¯SIMD[type, size]ã€‚å„˜ç®¡å°‡å…¶å¯«å‡ºæ˜¯æœ‰æ•ˆçš„ï¼ˆå¦‚ çš„è¿”å›é¡å‹æ‰€ç¤ºsplat()ï¼‰ï¼Œä½†é€™å¯èƒ½æœƒå¾ˆå†—é•·ï¼Œå› æ­¤æˆ‘å€‘å»ºè­°åƒç¤ºä¾‹ä¸€æ¨£ä½¿ç”¨è©²Selfé¡å‹ï¼ˆä¾†è‡ªPEP673ï¼‰__add__ã€‚

åƒæ•¸é‡è¼‰
å‡½æ•¸å’Œæ–¹æ³•å¯ä»¥åœ¨å…¶åƒæ•¸ç°½åä¸Šé‡è¼‰ã€‚é‡è¼‰æ±ºç­–é‚è¼¯æ ¹æ“šä»¥ä¸‹è¦å‰‡ï¼ˆæŒ‰å„ªå…ˆé †åºï¼‰éæ¿¾å€™é¸è€…ï¼š

å…·æœ‰æœ€å°‘æ•¸é‡éš±å¼è½‰æ›ï¼ˆåœ¨å¯¦åƒå’Œåƒæ•¸ä¸­ï¼‰çš„å€™é¸è€…ã€‚
æ²’æœ‰å¯è®Šåƒæ•¸çš„å€™é¸äººã€‚
æ²’æœ‰å¯è®Šåƒæ•¸çš„å€™é¸è€…ã€‚
å…·æœ‰æœ€çŸ­åƒæ•¸ç°½åçš„å€™é¸è€…ã€‚
å¦‚æœæ‡‰ç”¨é€™äº›è¦å‰‡å¾Œå­˜åœ¨å¤šå€‹å€™é¸è€…ï¼Œå‰‡é‡è¼‰æ±ºç­–å°‡å¤±æ•—ã€‚ä¾‹å¦‚ï¼š

@register_passable("trivial")
struct MyInt:
    """A type that is implicitly convertible to `Int`."""
    var value: Int

    @always_inline("nodebug")
    fn __init__(_a: Int) -> Self:
        return Self {value: _a}

fn foo[x: MyInt, a: Int]():
  print("foo[x: MyInt, a: Int]()")

fn foo[x: MyInt, y: MyInt]():
  print("foo[x: MyInt, y: MyInt]()")

fn bar[a: Int](b: Int):
  print("bar[a: Int](b: Int)")

fn bar[a: Int](*b: Int):
  print("bar[a: Int](*b: Int)")

fn bar[*a: Int](b: Int):
  print("bar[*a: Int](b: Int)")

fn parameter_overloads[a: Int, b: Int, x: MyInt]():
    # `foo[x: MyInt, a: Int]()` is called because it requires no implicit
    # conversions, whereas `foo[x: MyInt, y: MyInt]()` requires one.
    foo[x, a]()

    # `bar[a: Int](b: Int)` is called because it does not have variadic
    # arguments or parameters.
    bar[a](b)

    # `bar[*a: Int](b: Int)` is called because it has variadic parameters.
    bar[a, a, a](b)

parameter_overloads[1, 2, MyInt(3)]()

foo[x: MyInt, a: Int]()
bar[a: Int](b: Int)
bar[*a: Int](b: Int)
ä½¿ç”¨åƒæ•¸åŒ–é¡å‹å’Œå‡½æ•¸
æ‚¨å¯ä»¥é€šéå°‡å€¼å‚³éçµ¦æ–¹æ‹¬è™Ÿä¸­çš„åƒæ•¸ä¾†å¯¦ä¾‹åŒ–åƒæ•¸é¡å‹å’Œå‡½æ•¸ã€‚ä¾‹å¦‚ï¼Œå°æ–¼SIMDä¸Šé¢çš„é¡å‹ï¼ŒtypeæŒ‡å®šæ•¸æ“šé¡å‹ä¸¦sizeæŒ‡å®šSIMDå‘é‡çš„é•·åº¦ï¼ˆå¿…é ˆæ˜¯2çš„å†ªï¼‰ï¼š

from DType import DType
from SIMD import SIMD

# Make a vector of 4 floats.
let small_vec = SIMD[DType.float32, 4](1.0, 2.0, 3.0, 4.0)

# Make a big vector containing 1.0 in float16 format.
let big_vec = SIMD[DType.float16, 32].splat(1.0)

# Do some math and convert the elements to float32.
let bigger_vec = (big_vec+big_vec).cast[DType.float32]()

# You can write types out explicitly if you want of course.
let bigger_vec2 : SIMD[DType.float32, 32] = bigger_vec

print('small_vec type:', small_vec.element_type, 'length:', len(small_vec))
print('bigger_vec2 type:', bigger_vec2.element_type, 'length:', len(bigger_vec2))

small_vec type: float32 length: 4
bigger_vec2 type: float32 length: 32
è«‹æ³¨æ„ï¼Œè©²cast()æ–¹æ³•é‚„éœ€è¦ä¸€å€‹åƒæ•¸ä¾†æŒ‡å®šæ‚¨æƒ³è¦çš„é¡å‹è½‰æ›ï¼ˆä¸Šé¢çš„æ–¹æ³•å®šç¾©éœ€è¦ä¸€å€‹targetåƒæ•¸å€¼ï¼‰ã€‚å› æ­¤ï¼Œå°±åƒSIMDçµæ§‹æ˜¯æ³›å‹é¡å‹å®šç¾©ä¸€æ¨£ï¼Œcast()æ–¹æ³•ä¹Ÿæ˜¯æ³›å‹æ–¹æ³•å®šç¾©ï¼Œå®ƒæ ¹æ“šåƒæ•¸å€¼åœ¨ç·¨è­¯æ™‚è€Œä¸æ˜¯é‹è¡Œæ™‚å¯¦ä¾‹åŒ–ã€‚

ä¸Šé¢çš„ä»£ç¢¼é¡¯ç¤ºäº†å…·é«”é¡å‹çš„ä½¿ç”¨ï¼ˆå³ï¼Œå®ƒSIMDä½¿ç”¨å·²çŸ¥é¡å‹å€¼é€²è¡Œå¯¦ä¾‹åŒ–ï¼‰ï¼Œä½†åƒæ•¸çš„ä¸»è¦åŠŸèƒ½ä¾†è‡ªæ–¼å®šç¾©åƒæ•¸ç®—æ³•å’Œé¡å‹ï¼ˆä½¿ç”¨åƒæ•¸å€¼çš„ä»£ç¢¼ï¼‰çš„èƒ½åŠ›ã€‚ä¾‹å¦‚ï¼Œä»¥ä¸‹æ˜¯å¦‚ä½•å®šç¾©èˆ‡SIMDé¡å‹å’Œå¯¬åº¦ç„¡é—œçš„åƒæ•¸ç®—æ³•ï¼š

from Math import sqrt

fn rsqrt[dt: DType, width: Int](x: SIMD[dt, width]) -> SIMD[dt, width]:
    return 1 / sqrt(x)

print(rsqrt[DType.float16, 4](42))

[0.154296875, 0.154296875, 0.154296875, 0.154296875]
è«‹æ³¨æ„ï¼Œxåƒæ•¸å¯¦éš›ä¸Šæ˜¯SIMDåŸºæ–¼å‡½æ•¸åƒæ•¸çš„é¡å‹ã€‚é‹è¡Œæ™‚ç¨‹åºå¯ä»¥ä½¿ç”¨åƒæ•¸çš„å€¼ï¼Œå› ç‚ºåƒæ•¸åœ¨é‹è¡Œæ™‚ç¨‹åºéœ€è¦å®ƒå€‘ä¹‹å‰åœ¨ç·¨è­¯æ™‚è§£æï¼ˆä½†ç·¨è­¯æ™‚åƒæ•¸è¡¨é”å¼ä¸èƒ½ä½¿ç”¨é‹è¡Œæ™‚å€¼ï¼‰ã€‚

Mojo ç·¨è­¯å™¨å°æ–¼åƒæ•¸çš„é¡å‹æ¨æ–·ä¹Ÿå¾ˆæ™ºèƒ½ã€‚è«‹æ³¨æ„ï¼Œä¸Šè¿°å‡½æ•¸ç„¡éœ€sqrt()æŒ‡å®šåƒæ•¸å³å¯èª¿ç”¨åƒæ•¸å‡½æ•¸ - ç·¨è­¯å™¨æœƒæ¨æ–·å…¶åƒæ•¸ï¼Œå°±åƒæ‚¨sqrt[type, simd_width](x)é¡¯å¼ç·¨å¯«ä¸€æ¨£ã€‚å¦è«‹æ³¨æ„ï¼Œrsqrt()é¸æ“‡å®šç¾©å…¶ç¬¬ä¸€å€‹åƒæ•¸ name ï¼Œwidthå³ä½¿SIMDé¡å‹å°‡å…¶å‘½åç‚º it sizeï¼Œä¹Ÿæ²’æœ‰å•é¡Œã€‚

åƒæ•¸è¡¨é”å¼åªæ˜¯ Mojo ä»£ç¢¼
a+båƒæ•¸è¡¨é”å¼æ˜¯å‡ºç¾åœ¨éœ€è¦åƒæ•¸çš„ä½ç½®çš„ä»»ä½•ä»£ç¢¼è¡¨é”å¼ï¼ˆä¾‹å¦‚ï¼‰ã€‚åƒæ•¸è¡¨é”å¼æ”¯æŒé‹ç®—ç¬¦å’Œå‡½æ•¸èª¿ç”¨ï¼Œå°±åƒé‹è¡Œæ™‚ä»£ç¢¼ä¸€æ¨£ï¼Œä¸¦ä¸”æ‰€æœ‰åƒæ•¸é¡å‹éƒ½ä½¿ç”¨èˆ‡é‹è¡Œæ™‚ç¨‹åºç›¸åŒçš„é¡å‹ç³»çµ±ï¼ˆä¾‹å¦‚Intå’ŒDTypeï¼‰ã€‚

ç”±æ–¼åƒæ•¸è¡¨é”å¼ä½¿ç”¨èˆ‡é‹è¡Œæ™‚ Mojo ä»£ç¢¼ç›¸åŒçš„èªæ³•å’Œé¡å‹ï¼Œå› æ­¤æ‚¨å¯ä»¥ä½¿ç”¨è¨±å¤šâ€œä¾è³´é¡å‹â€åŠŸèƒ½ã€‚ä¾‹å¦‚ï¼Œæ‚¨å¯èƒ½æƒ³è¦å®šç¾©ä¸€å€‹è¼”åŠ©å‡½æ•¸ä¾†é€£æ¥å…©å€‹ SIMD å‘é‡ï¼š

fn concat[ty: DType, len1: Int, len2: Int](
        lhs: SIMD[ty, len1], rhs: SIMD[ty, len2]) -> SIMD[ty, len1+len2]:

    var result = SIMD[ty, len1 + len2]()
    for i in range(len1):
        result[i] = SIMD[ty, 1](lhs[i])
    for j in range(len2):
        result[len1 + j] = SIMD[ty, 1](rhs[j])
    return result

let a = SIMD[DType.float32, 2](1, 2)
let x = concat[DType.float32, 2, 2](a, a)

print('result type:', x.element_type, 'length:', len(x))

result type: float32 length: 4
è«‹æ³¨æ„ï¼Œçµæœé•·åº¦æ˜¯è¼¸å…¥å‘é‡é•·åº¦çš„ç¸½å’Œï¼Œæ‚¨å¯ä»¥é€šéç°¡å–®çš„+æ“ä½œä¾†è¡¨é”å®ƒã€‚å°æ–¼æ›´è¤‡é›œçš„ç¤ºä¾‹ï¼Œè«‹çœ‹ä¸€ä¸‹SIMD.shuffle()æ¨™æº–åº«ä¸­çš„æ–¹æ³•ï¼šå®ƒæ¥å—å…©å€‹è¼¸å…¥ SIMD å€¼ã€ä¸€å€‹å‘é‡æ´—ç‰Œæ©ç¢¼ä½œç‚ºåˆ—è¡¨ï¼Œä¸¦è¿”å›ä¸€å€‹èˆ‡æ´—ç‰Œæ©ç¢¼é•·åº¦åŒ¹é…çš„ SIMDã€‚

å¼·å¤§çš„ç·¨è­¯æ™‚ç·¨ç¨‹
é›–ç„¶ç°¡å–®çš„è¡¨é”å¼å¾ˆæœ‰ç”¨ï¼Œä½†æœ‰æ™‚æ‚¨å¸Œæœ›ä½¿ç”¨æ§åˆ¶æµç·¨å¯«å‘½ä»¤å¼ç·¨è­¯æ™‚é‚è¼¯ã€‚ä¾‹å¦‚ï¼Œisclose()MojoMathæ¨¡å¡Šä¸­çš„å‡½æ•¸å°æ•´æ•¸ä½¿ç”¨ç²¾ç¢ºç›¸ç­‰ï¼Œä½†å°æµ®é»ä½¿ç”¨â€œæ¥è¿‘â€æ¯”è¼ƒã€‚æ‚¨ç”šè‡³å¯ä»¥é€²è¡Œç·¨è­¯æ™‚éæ­¸ã€‚ä¾‹å¦‚ï¼Œä¸‹é¢æ˜¯ä¸€å€‹ç¤ºä¾‹â€œæ¨¹ç¸®æ¸›â€ç®—æ³•ï¼Œå®ƒå°‡å‘é‡çš„æ‰€æœ‰å…ƒç´ éæ­¸åœ°æ±‚å’Œç‚ºæ¨™é‡ï¼š

fn slice[ty: DType, new_size: Int, size: Int](
        x: SIMD[ty, size], offset: Int) -> SIMD[ty, new_size]:
    var result = SIMD[ty, new_size]()
    for i in range(new_size):
        result[i] = SIMD[ty, 1](x[i + offset])
    return result

fn reduce_add[ty: DType, size: Int](x: SIMD[ty, size]) -> Int:
    @parameter
    if size == 1:
        return x[0].to_int()
    elif size == 2:
        return x[0].to_int() + x[1].to_int()

    # Extract the top/bottom halves, add them, sum the elements.
    alias half_size = size // 2
    let lhs = slice[ty, half_size, size](x, 0)
    let rhs = slice[ty, half_size, size](x, half_size)
    return reduce_add[ty, half_size](lhs + rhs)
    
let x = SIMD[DType.index, 4](1, 2, 3, 4)
print(x)
print("Elements sum:", reduce_add[DType.index, 4](x))

[1, 2, 3, 4]
Elements sum: 10
é€™åˆ©ç”¨äº†è©²@parameter ifåŠŸèƒ½ï¼Œå³ifåœ¨ç·¨è­¯æ™‚é‹è¡Œçš„èªå¥ã€‚å®ƒè¦æ±‚å…¶æ¢ä»¶æ˜¯æœ‰æ•ˆçš„åƒæ•¸è¡¨é”å¼ï¼Œä¸¦ç¢ºä¿åªæœ‰èªå¥çš„å¯¦æ™‚åˆ†æ”¯ifè¢«ç·¨è­¯åˆ°ç¨‹åºä¸­ã€‚

Mojo é¡å‹åªæ˜¯åƒæ•¸è¡¨é”å¼
é›–ç„¶æˆ‘å€‘å·²ç¶“å±•ç¤ºç­å¦‚ä½•åœ¨é¡å‹ä¸­ä½¿ç”¨åƒæ•¸è¡¨é”å¼ï¼Œä½†é¡å‹è¨»é‡‹æœ¬èº«å¯ä»¥æ˜¯ä»»æ„è¡¨é”å¼ï¼ˆå°±åƒåœ¨ Python ä¸­ä¸€æ¨£ï¼‰ã€‚Mojo ä¸­çš„é¡å‹å…·æœ‰ç‰¹æ®Šçš„å…ƒé¡å‹ï¼Œå…è¨±å®šç¾©é¡å‹åƒæ•¸ç®—æ³•å’Œå‡½æ•¸ã€‚

ä¾‹å¦‚ï¼Œæˆ‘å€‘å¯ä»¥å‰µå»ºä¸€å€‹Arrayæ”¯æŒä»»æ„é¡å‹å…ƒç´ çš„ç°¡åŒ–ç‰ˆæœ¬ï¼ˆé€šéAnyTypeåƒæ•¸ï¼‰ï¼š

struct Array[T: AnyType]:
    var data: Pointer[T]
    var size: Int
    var cap: Int

    fn __init__(inout self, size: Int, value: T):
        self.cap = size * 2
        self.size = size
        self.data = Pointer[T].alloc(self.cap)
        for i in range(self.size):
            self.data.store(i, value)
              
    fn __getitem__(self, i: Int) -> T:
        return self.data.load(i)

    fn __del__(owned self):
        self.data.free()

var v = Array[Float32](4, 3.14)
print(v[0], v[1], v[2], v[3])

3.1400001049041748 3.1400001049041748 3.1400001049041748 3.1400001049041748
è«‹æ³¨æ„ï¼ŒTåƒæ•¸è¢«ç”¨ä½œåƒæ•¸çš„å½¢å¼é¡å‹valueå’Œå‡½æ•¸çš„è¿”å›é¡å‹__getitem__ã€‚åƒæ•¸å…è¨±Arrayé¡å‹æ ¹æ“šä¸åŒçš„ç”¨ä¾‹æä¾›ä¸åŒçš„ APIã€‚

é‚„æœ‰è¨±å¤šå…¶ä»–æƒ…æ³å¯ä»¥å¾åƒæ•¸çš„æ›´é«˜ç´šä½¿ç”¨ä¸­å—ç›Šã€‚ä¾‹å¦‚ï¼Œæ‚¨å¯ä»¥ä¸¦è¡ŒåŸ·è¡Œé–‰åŒ… N æ¬¡ï¼Œä¸¦å¾ä¸Šä¸‹æ–‡ä¸­è¼¸å…¥ä¸€å€‹å€¼ï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼š

fn parallelize[func: fn (Int) -> None](num_work_items: Int):
    # Not actually parallel: see the 'Functional' module for real implementation.
    for i in range(num_work_items):
        func(i)

å¦ä¸€å€‹é‡è¦çš„ä¾‹å­æ˜¯å¯è®Šåƒæ•¸æ³›å‹ï¼Œå…¶ä¸­å¯èƒ½éœ€è¦åœ¨ç•°æ§‹é¡å‹åˆ—è¡¨ä¸Šå®šç¾©ç®—æ³•æˆ–æ•¸æ“šçµæ§‹ï¼Œä¾‹å¦‚å…ƒçµ„ï¼š

struct Tuple[*Ts: AnyType]:
    var _storage : *Ts

å„˜ç®¡æˆ‘å€‘é‚„æ²’æœ‰è¶³å¤ çš„å…ƒé¡å‹åŠ©æ‰‹ï¼Œä½†æˆ‘å€‘å°‡ä¾†æ‡‰è©²èƒ½å¤ ç·¨å¯«é¡ä¼¼çš„æ±è¥¿ï¼ˆå„˜ç®¡é‡è¼‰ä»ç„¶æ˜¯è™•ç†æ­¤å•é¡Œçš„æ›´å¥½æ–¹æ³•ï¼‰ï¼š

struct Array[T: AnyType]:
    fn __getitem__[IndexType: AnyType](self, idx: IndexType)
       -> (ArraySlice[T] if issubclass(IndexType, Range) else T):
       ...

alias: å‘½ååƒæ•¸è¡¨é”å¼
æƒ³è¦å‘½åç·¨è­¯æ™‚å€¼æ˜¯å¾ˆå¸¸è¦‹çš„ã€‚é›–ç„¶varå®šç¾©äº†é‹è¡Œæ™‚å€¼ä¸¦letå®šç¾©äº†é‹è¡Œæ™‚å¸¸é‡ï¼Œä½†æˆ‘å€‘éœ€è¦ä¸€ç¨®æ–¹æ³•ä¾†å®šç¾©ç·¨è­¯æ™‚è‡¨æ™‚å€¼ã€‚ç‚ºæ­¤ï¼ŒMojo ä½¿ç”¨aliasè²æ˜ã€‚

ä¾‹å¦‚ï¼Œè©²DTypeçµæ§‹ä½¿ç”¨æšèˆ‰å™¨çš„åˆ¥åå¯¦ç¾ä¸€å€‹ç°¡å–®çš„æšèˆ‰ï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼ˆå¯¦éš›DTypeå¯¦ç¾ç´°ç¯€ç•¥æœ‰ä¸åŒï¼‰ï¼š

struct DType:
    var value : UI8
    alias invalid = DType(0)
    alias bool = DType(1)
    alias int8 = DType(2)
    alias uint8 = DType(3)
    alias int16 = DType(4)
    alias int16 = DType(5)
    ...
    alias float32 = DType(15)

é€™å…è¨±å®¢æˆ¶ç«¯è‡ªç„¶åœ°ç”¨ä½œDType.float32åƒæ•¸è¡¨é”å¼ï¼ˆä¹Ÿå¯ä»¥ç”¨ä½œé‹è¡Œæ™‚å€¼ï¼‰ã€‚DTypeè«‹æ³¨æ„ï¼Œé€™æ˜¯åœ¨ç·¨è­¯æ™‚èª¿ç”¨é‹è¡Œæ™‚æ§‹é€ å‡½æ•¸ã€‚

é¡å‹æ˜¯åˆ¥åçš„å¦ä¸€å€‹å¸¸è¦‹ç”¨é€”ã€‚å› ç‚ºé¡å‹æ˜¯ç·¨è­¯æ™‚è¡¨é”å¼ï¼Œæ‰€ä»¥èƒ½å¤ å¾ˆæ–¹ä¾¿åœ°åŸ·è¡Œä»¥ä¸‹æ“ä½œï¼š

alias Float16 = SIMD[DType.float16, 1]
alias UInt8 = SIMD[DType.uint8, 1]

var x : Float16   # F16 works like a "typedef"

èˆ‡varå’Œ ä¸€æ¨£letï¼Œåˆ¥åéµå¾ªç¯„åœï¼Œä¸¦ä¸”æ‚¨å¯ä»¥æŒ‰ç…§é æœŸåœ¨å‡½æ•¸ä¸­ä½¿ç”¨æœ¬åœ°åˆ¥åã€‚

é †ä¾¿èªªä¸€ä¸‹ï¼Œ å’ŒNoneéƒ½AnyTypeè¢«å®šç¾©ç‚ºé¡å‹åˆ¥åã€‚

è‡ªå‹•èª¿æ•´/è‡ªé©æ‡‰ç·¨è­¯
Mojo åƒæ•¸è¡¨é”å¼å…è¨±æ‚¨åƒåœ¨å…¶ä»–èªè¨€ä¸­ä¸€æ¨£ç·¨å¯«å¯ç§»æ¤çš„åƒæ•¸ç®—æ³•ï¼Œä½†æ˜¯åœ¨ç·¨å¯«é«˜æ€§èƒ½ä»£ç¢¼æ™‚ï¼Œæ‚¨ä»ç„¶å¿…é ˆé¸æ“‡ç”¨æ–¼åƒæ•¸çš„å…·é«”å€¼ã€‚ä¾‹å¦‚ï¼Œåœ¨ç·¨å¯«é«˜æ€§èƒ½æ•¸å€¼ç®—æ³•æ™‚ï¼Œæ‚¨å¯èƒ½å¸Œæœ›ä½¿ç”¨å…§å­˜å¹³é‹ªä¾†åŠ é€Ÿç®—æ³•ï¼Œä½†è¦ä½¿ç”¨çš„ç¶­åº¦åœ¨å¾ˆå¤§ç¨‹åº¦ä¸Šå–æ±ºæ–¼å¯ç”¨çš„ç¡¬ä»¶åŠŸèƒ½ã€ç·©å­˜çš„å¤§å°ã€èåˆåˆ°å…§æ ¸ä¸­çš„å…§å®¹ä»¥åŠè¨±å¤šå…¶ä»–ç¹ç‘£çš„ç´°ç¯€ã€‚

å³ä½¿å‘é‡é•·åº¦ä¹Ÿå¯èƒ½é›£ä»¥ç®¡ç†ï¼Œå› ç‚ºå…¸å‹æ©Ÿå™¨çš„å‘é‡é•·åº¦å–æ±ºæ–¼æ•¸æ“šé¡å‹ï¼Œä¸¦ä¸”æŸäº›æ•¸æ“šé¡å‹bfloat16ä¸¦ä¸å®Œå…¨æ”¯æŒæ‰€æœ‰å¯¦ç¾ã€‚Mojo é€šéautotuneåœ¨æ¨™æº–åº«ä¸­æä¾›ä¸€å€‹å‡½æ•¸ä¾†æä¾›å¹«åŠ©ã€‚ä¾‹å¦‚ï¼Œå¦‚æœæ‚¨æƒ³å°‡èˆ‡å‘é‡é•·åº¦ç„¡é—œçš„ç®—æ³•å¯«å…¥æ•¸æ“šç·©è¡å€ï¼Œæ‚¨å¯ä»¥é€™æ¨£ç·¨å¯«ï¼š

from DType import DType
from Autotune import autotune, search
from Benchmark import Benchmark
from Pointer import DTypePointer
from Functional import vectorize

fn buffer_elementwise_add_impl[
    dt: DType
](lhs: DTypePointer[dt], rhs: DTypePointer[dt], result: DTypePointer[dt], N: Int):
    """Perform elementwise addition of N elements in RHS and LHS and store
    the result in RESULT.
    """
    @parameter
    fn add_simd[size: Int](idx: Int):
        let lhs_simd = lhs.simd_load[size](idx)
        let rhs_simd = rhs.simd_load[size](idx)
        result.simd_store[size](idx, lhs_simd + rhs_simd)
    
    # Pick vector length for this dtype and hardware
    alias vector_len = autotune(1, 4, 8, 16, 32)

    # Use it as the vectorization length
    vectorize[vector_len, add_simd](N)

fn elementwise_evaluator[dt: DType](
    fns: Pointer[fn (DTypePointer[dt], DTypePointer[dt], DTypePointer[dt], Int) -> None],
    num: Int,
) -> Int:
    # Benchmark the implementations on N = 64.
    alias N = 64
    let lhs = DTypePointer[dt].alloc(N)
    let rhs = DTypePointer[dt].alloc(N)
    let result = DTypePointer[dt].alloc(N)

    # Fill with ones.
    for i in range(N):
        lhs.store(i, 1)
        rhs.store(i, 1)

    # Find the fastest implementation.
    var best_idx: Int = -1
    var best_time: Int = -1
    for i in range(num):
        @parameter
        fn wrapper():
            fns.load(i)(lhs, rhs, result, N)
        let cur_time = Benchmark(1).run[wrapper]()
        if best_idx < 0 or best_time > cur_time:
            best_idx = i
            best_time = cur_time
        print("time[", i, "] =", cur_time)
    print("selected:", best_idx)
    return best_idx

fn buffer_elementwise_add[
    dt: DType
](lhs: DTypePointer[dt], rhs: DTypePointer[dt], result: DTypePointer[dt], N: Int):
    # Forward declare the result parameter.
    alias best_impl: fn(DTypePointer[dt], DTypePointer[dt], DTypePointer[dt], Int) -> None

    # Perform search!
    search[
      fn(DTypePointer[dt], DTypePointer[dt], DTypePointer[dt], Int) -> None,
      buffer_elementwise_add_impl[dt],
      elementwise_evaluator[dt] -> best_impl
    ]()

    # Call the select implementation
    best_impl(lhs, rhs, result, N)

æˆ‘å€‘ç¾åœ¨å¯ä»¥åƒå¾€å¸¸ä¸€æ¨£èª¿ç”¨æˆ‘å€‘çš„å‡½æ•¸ï¼š

let N = 32
let a = DTypePointer[DType.float32].alloc(N)
let b = DTypePointer[DType.float32].alloc(N)
let res = DTypePointer[DType.float32].alloc(N)
# Initialize arrays with some values
for i in range(N):
    a.store(i, 2.0)
    b.store(i, 40.0)
    res.store(i, -1)
    
buffer_elementwise_add[DType.float32](a, b, res, N)
print(a.load(10), b.load(10), res.load(10))

time[ 0 ] = 24
time[ 1 ] = 6
time[ 2 ] = 4
time[ 3 ] = 4
time[ 4 ] = 4
selected: 2
2.0 40.0 42.0
ç·¨è­¯æ­¤ä»£ç¢¼çš„å¯¦ä¾‹æ™‚ï¼ŒMojo æœƒåˆ†å‰æ­¤ç®—æ³•çš„ç·¨è­¯ï¼Œä¸¦é€šéæ¸¬é‡åœ¨å¯¦è¸ä¸­æœ€é©åˆç›®æ¨™ç¡¬ä»¶çš„å€¼ä¾†æ±ºå®šä½¿ç”¨å“ªå€‹å€¼ã€‚å®ƒè©•ä¼°è¡¨é”å¼çš„ä¸åŒå€¼vector_lenï¼Œä¸¦æ ¹æ“šç”¨æˆ¶å®šç¾©çš„æ€§èƒ½è©•ä¼°å™¨é¸æ“‡æœ€å¿«çš„å€¼ã€‚ä¾‹å¦‚ï¼Œå› ç‚ºå®ƒå–®ç¨æ¸¬é‡å’Œè©•ä¼°æ¯å€‹é¸é …ï¼Œæ‰€ä»¥å®ƒå¯èƒ½æœƒç‚º é¸å–ä¸åŒçš„å‘é‡é•·åº¦float32ã€‚int8é€™å€‹ç°¡å–®çš„åŠŸèƒ½éå¸¸å¼·å¤§â€”â€”è¶…è¶Šäº†ç°¡å–®çš„æ•´æ•¸å¸¸é‡â€”â€”å› ç‚ºå‡½æ•¸å’Œé¡å‹ä¹Ÿæ˜¯åƒæ•¸è¡¨é”å¼ã€‚

è«‹æ³¨æ„ï¼Œæœ€ä½³å‘é‡é•·åº¦çš„æœç´¢æ˜¯ç”±è©²search()å‡½æ•¸åŸ·è¡Œçš„ã€‚search()æ¥å—ä¸€å€‹è©•ä¼°å™¨å’Œä¸€å€‹åˆ†å‰å‡½æ•¸ï¼Œä¸¦è¿”å›è©•ä¼°å™¨é¸æ“‡çš„æœ€å¿«å¯¦ç¾ä½œç‚ºåƒæ•¸çµæœã€‚è¦æ›´æ·±å…¥åœ°äº†è§£æ­¤ä¸»é¡Œï¼Œè«‹æŸ¥çœ‹æœ‰é—œMojo ä¸­çš„çŸ©é™£ä¹˜æ³•å’ŒFast Memsetçš„ç­†è¨˜æœ¬ã€‚

è‡ªå‹•èª¿å„ªæœ¬è³ªä¸Šæ˜¯ä¸€ç¨®æŒ‡æ•¸æŠ€è¡“ï¼Œå—ç›Šæ–¼ Mojo ç·¨è­¯å™¨å †æ£§çš„å…§éƒ¨å¯¦ç¾ç´°ç¯€ï¼ˆç‰¹åˆ¥æ˜¯ MLIRã€é›†æˆç·©å­˜å’Œç·¨è­¯åˆ†ç™¼ï¼‰ã€‚é€™ä¹Ÿæ˜¯ä¸€å€‹é«˜ç´šç”¨æˆ¶åŠŸèƒ½ï¼Œéœ€è¦éš¨è‘—æ™‚é–“çš„æ¨ç§»ä¸æ–·é–‹ç™¼å’Œè¿­ä»£ã€‚

â€œåƒ¹å€¼ç”Ÿå‘½é€±æœŸâ€ï¼šåƒ¹å€¼çš„èª•ç”Ÿã€å­˜åœ¨å’Œæ¶ˆäº¡
æ­¤æ™‚ï¼Œæ‚¨æ‡‰è©²äº†è§£ Mojo å‡½æ•¸å’Œé¡å‹çš„æ ¸å¿ƒèªç¾©å’ŒåŠŸèƒ½ï¼Œå› æ­¤æˆ‘å€‘ç¾åœ¨å¯ä»¥è¨è«–å®ƒå€‘å¦‚ä½•çµ„åˆåœ¨ä¸€èµ·ä»¥åœ¨ Mojo ä¸­è¡¨é”æ–°é¡å‹ã€‚

è¨±å¤šç¾æœ‰èªè¨€éƒ½é€šéä¸åŒçš„æ¬Šè¡¡ä¾†è¡¨é”è¨­è¨ˆé»ï¼šä¾‹å¦‚ï¼ŒC++ éå¸¸å¼·å¤§ï¼Œä½†ç¶“å¸¸è¢«æŒ‡è²¬â€œé»˜èªè¨­ç½®éŒ¯èª¤â€ï¼Œå¾è€Œå°è‡´éŒ¯èª¤å’ŒéŒ¯èª¤åŠŸèƒ½ã€‚Swift æ˜“æ–¼ä½¿ç”¨ï¼Œä½†å…¶æ¨¡å‹çš„å¯é æ¸¬æ€§è¼ƒå·®ï¼Œæœƒå¾©åˆ¶å¤§é‡å€¼ï¼Œä¸¦ä¸”ä¾è³´æ–¼â€œARC å„ªåŒ–å™¨â€ä¾†æé«˜æ€§èƒ½ã€‚Rust å¾å¼·å¤§çš„åƒ¹å€¼æ‰€æœ‰æ¬Šç›®æ¨™é–‹å§‹ï¼Œä»¥æ»¿è¶³å…¶å€Ÿç”¨æª¢æŸ¥å™¨çš„è¦æ±‚ï¼Œä½†ä¾è³´æ–¼å¯ç§»å‹•çš„å€¼ï¼Œé€™ä½¿å¾—è¡¨é”è‡ªå®šç¾©ç§»å‹•æ§‹é€ å‡½æ•¸è®Šå¾—å…·æœ‰æŒ‘æˆ°æ€§ï¼Œä¸¦ä¸”æœƒçµ¦æ€§èƒ½å¸¶ä¾†å¾ˆå¤§çš„å£“åŠ›memcpyã€‚åœ¨Pythonä¸­ï¼Œä¸€åˆ‡éƒ½æ˜¯å°é¡çš„å¼•ç”¨ï¼Œå› æ­¤å®ƒæ°¸é ä¸æœƒçœŸæ­£é¢è‡¨é¡å‹å•é¡Œã€‚

å°æ–¼ Mojoï¼Œæˆ‘å€‘å¾é€™äº›ç¾æœ‰ç³»çµ±ä¸­å­¸ç¿’ï¼Œæˆ‘å€‘çš„ç›®æ¨™æ˜¯æä¾›ä¸€å€‹éå¸¸å¼·å¤§ä¸”æ˜“æ–¼å­¸ç¿’å’Œç†è§£çš„æ¨¡å‹ã€‚æˆ‘å€‘ä¹Ÿä¸æƒ³è¦æ±‚â€œç›¡æœ€å¤§åŠªåŠ›â€å’Œé›£ä»¥é æ¸¬çš„å„ªåŒ–éç¨‹å…§ç½®åˆ°â€œè¶³å¤ æ™ºèƒ½â€çš„ç·¨è­¯å™¨ä¸­ã€‚

ç‚ºäº†æ¢ç´¢é€™äº›å•é¡Œï¼Œæˆ‘å€‘ç ”ç©¶äº†ä¸åŒçš„åƒ¹å€¼åˆ†é¡å’Œè¡¨é”å®ƒå€‘çš„ç›¸é—œ Mojo åŠŸèƒ½ï¼Œä¸¦è‡ªä¸‹è€Œä¸Šæ§‹å»ºã€‚æˆ‘å€‘åœ¨ç¤ºä¾‹ä¸­ä½¿ç”¨ C++ ä½œç‚ºä¸»è¦æ¯”è¼ƒé»ï¼Œå› ç‚ºå®ƒçœ¾æ‰€å‘¨çŸ¥ï¼Œä½†å¦‚æœå…¶ä»–èªè¨€æä¾›äº†æ›´å¥½çš„æ¯”è¼ƒé»ï¼Œæˆ‘å€‘å¶çˆ¾æœƒåƒè€ƒå®ƒå€‘ã€‚

ç„¡æ³•å¯¦ä¾‹åŒ–çš„é¡å‹
Mojo ä¸­æœ€ç°¡å–®çš„é¡å‹æ˜¯ä¸å…è¨±å‰µå»ºå®ƒçš„å¯¦ä¾‹çš„é¡å‹ï¼šé€™äº›é¡å‹æ ¹æœ¬æ²’æœ‰åˆå§‹åŒ–ç¨‹åºï¼Œå¦‚æœå®ƒå€‘æœ‰ææ§‹å‡½æ•¸ï¼Œå‰‡æ°¸é ä¸æœƒèª¿ç”¨å®ƒï¼ˆå› ç‚ºç„¡æ³•éŠ·æ¯€å¯¦ä¾‹ï¼‰ï¼š

struct NoInstances:
    var state: Int  # Pretty useless

    alias my_int = Int

    @staticmethod
    fn print_hello():
        print("hello world")

é»˜èªæƒ…æ³ä¸‹ï¼ŒMojo é¡å‹ä¸æœƒç²å¾—é»˜èªæ§‹é€ å‡½æ•¸ã€ç§»å‹•æ§‹é€ å‡½æ•¸ã€æˆå“¡åˆå§‹åŒ–å™¨æˆ–å…¶ä»–ä»»ä½•å…§å®¹ï¼Œå› æ­¤ä¸å¯èƒ½å‰µå»ºæ­¤NoInstancesé¡å‹çš„å¯¦ä¾‹ã€‚ç‚ºäº†ç²å¾—å®ƒå€‘ï¼Œæ‚¨éœ€è¦å®šç¾©ä¸€å€‹__init__æ–¹æ³•æˆ–ä½¿ç”¨åˆæˆåˆå§‹åŒ–ç¨‹åºçš„è£é£¾å™¨ã€‚å¦‚åœ–æ‰€ç¤ºï¼Œé€™äº›é¡å‹å¯ç”¨ä½œâ€œå‘½åç©ºé–“â€ï¼Œå› ç‚ºæ‚¨å¯ä»¥å¼•ç”¨éœæ…‹æˆå“¡ï¼Œä¾‹å¦‚NoInstances.my_intæˆ–NoInstances.print_hello()å³ä½¿æ‚¨ç„¡æ³•å¯¦ä¾‹åŒ–è©²é¡å‹çš„å¯¦ä¾‹ã€‚

ä¸å¯ç§»å‹•å’Œä¸å¯è¤‡åˆ¶é¡å‹
å¦‚æœæˆ‘å€‘åœ¨å¾©é›œæ€§çš„éšæ¢¯ä¸Šæ›´é€²ä¸€æ­¥ï¼Œæˆ‘å€‘å°‡å¾—åˆ°å¯ä»¥å¯¦ä¾‹åŒ–çš„é¡å‹ï¼Œä½†æ˜¯ä¸€æ—¦å®ƒå€‘è¢«å›ºå®šåˆ°å…§å­˜ä¸­çš„åœ°å€ï¼Œå®ƒå€‘å°±ä¸èƒ½è¢«éš±å¼ç§»å‹•æˆ–è¤‡åˆ¶ã€‚é€™å°æ–¼å¯¦ç¾åŸå­æ“ä½œï¼ˆä¾‹å¦‚std::atomicåœ¨ C++ ä¸­ï¼‰ç­‰é¡å‹æˆ–å…¶ä»–é¡å‹éå¸¸æœ‰ç”¨ï¼Œå…¶ä¸­å€¼çš„å…§å­˜åœ°å€æ˜¯å…¶æ¨™è­˜ä¸¦ä¸”å°å…¶ç”¨é€”è‡³é—œé‡è¦ï¼š

struct Atomic:
    var state: Int

    fn __init__(inout self, state: Int = 0):
        self.state = state

    fn __iadd__(inout self, rhs: Int):
        #...atomic magic...

    fn get_value(self) -> Int:
        return atomic_load_int(self.state)

æ­¤é¡å®šç¾©äº†ä¸€å€‹åˆå§‹åŒ–ç¨‹åºï¼Œä½†æ²’æœ‰å¾©è£½æˆ–ç§»å‹•æ§‹é€ å‡½æ•¸ï¼Œå› æ­¤ä¸€æ—¦åˆå§‹åŒ–ï¼Œå°±æ°¸é ç„¡æ³•ç§»å‹•æˆ–è¤‡åˆ¶ã€‚é€™æ˜¯å®‰å…¨ä¸”æœ‰ç”¨çš„ï¼Œå› ç‚º Mojo çš„æ‰€æœ‰æ¬Šç³»çµ±æ˜¯å®Œå…¨â€œåœ°å€æ­£ç¢ºçš„â€â€”â€”ç•¶å®ƒè¢«åˆå§‹åŒ–åˆ°å †æ£§æˆ–å…¶ä»–é¡å‹çš„å­—æ®µä¸­æ™‚ï¼Œå®ƒæ°¸é ä¸éœ€è¦ç§»å‹•ã€‚

è«‹æ³¨æ„ï¼ŒMojo çš„æ–¹æ³•åƒ…æ§åˆ¶å…§ç½®ç§»å‹•æ“ä½œï¼Œä¾‹å¦‚a = bå¾©åˆ¶å’Œ^å‚³è¼¸é‹ç®—ç¬¦ã€‚æ‚¨å¯ä»¥ç”¨æ–¼è‡ªå·±çš„é¡å‹ï¼ˆå¦‚ä¸ŠAtomicï¼‰çš„ä¸€ç¨®æœ‰ç”¨æ¨¡å¼æ˜¯æ·»åŠ é¡¯å¼copy()æ–¹æ³•ï¼ˆéâ€œdunderâ€æ–¹æ³•ï¼‰ã€‚ç•¶ç¨‹åºå“¡çŸ¥é“å¯¦ä¾‹æ˜¯å®‰å…¨çš„æ™‚ï¼Œé€™å°æ–¼è£½ä½œå¯¦ä¾‹çš„é¡¯å¼å‰¯æœ¬å¾ˆæœ‰ç”¨ã€‚

ç¨ç‰¹çš„â€œåƒ…ç§»å‹•â€é¡å‹
å¦‚æœæˆ‘å€‘åœ¨èƒ½åŠ›çš„éšæ¢¯ä¸Šå†ä¸Šä¸€å±¤æ¨“ï¼Œæˆ‘å€‘å°‡é‡åˆ°â€œå”¯ä¸€â€çš„é¡å‹ - C++ ä¸­æœ‰å¾ˆå¤šé€™æ¨£çš„ä¾‹å­ï¼Œä¾‹å¦‚é¡ä¼¼çš„é¡å‹ï¼Œç”šè‡³æ˜¯æ“æœ‰åº•å±¤ POSIX æ–‡ä»¶æè¿°ç¬¦çš„std::unique_ptré¡å‹FileDescriptorã€‚é€™äº›é¡å‹åœ¨ Rust ç­‰èªè¨€ä¸­å¾ˆæ™®éï¼Œä¸é¼“å‹µè¤‡è£½ï¼Œä½†â€œç§»å‹•â€æ˜¯å…è²»çš„ã€‚__moveinit__åœ¨ Mojo ä¸­ï¼Œæ‚¨å¯ä»¥é€šéå®šç¾©ç²å–å”¯ä¸€é¡å‹æ‰€æœ‰æ¬Šçš„æ–¹æ³•ä¾†å¯¦ç¾é€™äº›é¡å‹çš„ç§»å‹•ã€‚ä¾‹å¦‚ï¼š

# This is a simple wrapper around POSIX-style fcntl.h functions.
struct FileDescriptor:
    var fd: Int

    # This is how we move our unique type.
    fn __moveinit__(inout self, owned existing: Self):
        self.fd = existing.fd

    # This takes ownership of a POSIX file descriptor.
    fn __init__(inout self, fd: Int):
        self.fd = fd

    fn __init__(inout self, path: String):
        # Error handling omitted, call the open(2) syscall.
        self = FileDescriptor(open(path, ...))

    fn __del__(owned self):
        close(self.fd)   # pseudo code, call close(2)

    fn dup(self) -> Self:
        # Invoke the dup(2) system call.
        return Self(dup(self.fd))
    fn read(...): ...
    fn write(...): ...

æ¶ˆè²»ç§»å‹•æ§‹é€ å‡½æ•¸ ( __moveinit__) ç²å–ç¾æœ‰ çš„æ‰€æœ‰æ¬ŠFileDescriptorï¼Œä¸¦å°‡å…¶å…§éƒ¨å¯¦ç¾ç´°ç¯€ç§»å‹•åˆ°æ–°å¯¦ä¾‹ã€‚é€™æ˜¯å› ç‚º çš„å¯¦ä¾‹FileDescriptorå¯èƒ½å­˜åœ¨æ–¼ä¸åŒçš„ä½ç½®ï¼Œä¸¦ä¸”å®ƒå€‘å¯ä»¥åœ¨é‚è¼¯ä¸Šç§»å‹•â€”â€”ç«Šå–ä¸€å€‹å€¼çš„ä¸»é«”ä¸¦å°‡å…¶ç§»å‹•åˆ°å¦ä¸€å€‹å€¼ä¸­ã€‚

é€™æ˜¯ä¸€å€‹æœƒ__moveinit__å¤šæ¬¡èª¿ç”¨çš„ä»¤äººéœ‡é©šçš„ç¤ºä¾‹ï¼š

fn egregious_moves(owned fd1: FileDescriptor):
    # fd1 and fd2 have different addresses in memory, but the
    # transfer operator moves unique ownership from fd1 to fd2.
    let fd2 = fd1^

    # Do it again, a use of fd2 after this point will produce an error.
    let fd3 = fd2^

    # We can do this all day...
    let fd4 = fd3^
    fd4.read(...)
    # fd4.__del__() runs here

è«‹æ³¨æ„å¦‚ä½•ä½¿ç”¨å¾Œç¶´â€œè½‰ç§»â€é‹ç®—ç¬¦åœ¨æ“æœ‰è©²å€¼çš„å„å€‹å€¼ä¹‹é–“è½‰ç§»è©²å€¼çš„æ‰€æœ‰æ¬Š^ï¼Œé€™æœƒç ´å£å…ˆå‰çš„ç¶å®šä¸¦å°‡æ‰€æœ‰æ¬Šè½‰ç§»åˆ°æ–°çš„å¸¸é‡ã€‚å¦‚æœæ‚¨ç†Ÿæ‚‰ C++ï¼Œé‚£éº¼è€ƒæ…®è½‰ç§»é‹ç®—ç¬¦çš„ç°¡å–®æ–¹æ³•å°±åƒstd::moveï¼Œä½†åœ¨é€™ç¨®æƒ…æ³ä¸‹ï¼Œæˆ‘å€‘å¯ä»¥çœ‹åˆ°å®ƒèƒ½å¤ ç§»å‹•äº‹ç‰©ï¼Œè€Œç„¡éœ€å°‡å…¶é‡ç½®ç‚ºå¯ä»¥éŠ·æ¯€çš„ç‹€æ…‹ï¼šåœ¨ C++ ä¸­ï¼Œå¦‚æœæ‚¨çš„ç§»å‹•é‹ç®—ç¬¦ç„¡æ³•æ›´æ”¹èˆŠå€¼çš„å¯¦ä¾‹ï¼Œå®ƒå°‡è¢«é—œé–‰å…©æ¬¡fdã€‚

Mojo è·Ÿè¸ªå€¼çš„æ´»èºåº¦ä¸¦å…è¨±æ‚¨å®šç¾©è‡ªå®šç¾©ç§»å‹•æ§‹é€ å‡½æ•¸ã€‚é€™å¾ˆå°‘éœ€è¦ï¼Œä½†ä¸€æ—¦éœ€è¦å°±éå¸¸å¼·å¤§ã€‚ä¾‹å¦‚ï¼ŒæŸäº›é¡å‹å–œæ­¡llvm::SmallVector typeä½¿ç”¨â€œå…§è¯å­˜å„²â€å„ªåŒ–æŠ€è¡“ï¼Œä¸¦ä¸”å®ƒå€‘å¯èƒ½å¸Œæœ›é€šéâ€œå…§éƒ¨æŒ‡é‡â€ä¾†å¯¦ç¾åˆ°å…¶å¯¦ä¾‹ä¸­ã€‚é€™æ˜¯ä¸€å€‹çœ¾æ‰€å‘¨çŸ¥çš„æŠ€å·§ï¼Œå¯ä»¥æ¸›è¼• malloc å…§å­˜åˆ†é…å™¨çš„å£“åŠ›ï¼Œä½†é€™æ„å‘³è‘—â€œç§»å‹•â€æ“ä½œéœ€è¦è‡ªå®šç¾©é‚è¼¯ä¾†åœ¨ç™¼ç”Ÿé€™ç¨®æƒ…æ³æ™‚æ›´æ–°æŒ‡é‡ã€‚

ä½¿ç”¨ Mojoï¼Œé€™å°±åƒå¯¦ç¾è‡ªå®šç¾©__moveinit__æ–¹æ³•ä¸€æ¨£ç°¡å–®ã€‚é€™åœ¨ C++ ä¸­ä¹Ÿå¾ˆå®¹æ˜“å¯¦ç¾ï¼ˆä¸éï¼Œåœ¨ä¸éœ€è¦è‡ªå®šç¾©é‚è¼¯çš„æƒ…æ³ä¸‹å¯ä»¥ä½¿ç”¨æ¨£æ¿ï¼‰ï¼Œä½†åœ¨å…¶ä»–æµè¡Œçš„å…§å­˜å®‰å…¨èªè¨€ä¸­å¾ˆé›£å¯¦ç¾ã€‚

å¦ä¸€é»éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œé›–ç„¶ Mojo ç·¨è­¯å™¨æä¾›äº†è‰¯å¥½çš„å¯é æ¸¬æ€§å’Œæ§åˆ¶ï¼Œä½†å®ƒä¹Ÿéå¸¸è¤‡é›œã€‚å®ƒä¿ç•™æ¶ˆé™¤è‡¨æ™‚å’Œç›¸æ‡‰çš„è¤‡åˆ¶/ç§»å‹•æ“ä½œçš„æ¬Šåˆ©ã€‚å¦‚æœé€™ä¸é©åˆæ‚¨çš„é¡å‹ï¼Œæ‚¨æ‡‰è©²ä½¿ç”¨é¡¯å¼æ–¹æ³•ï¼ˆä¾‹å¦‚ï¼‰copy()è€Œä¸æ˜¯ dunder æ–¹æ³•ã€‚

æ”¯æŒâ€œå·èµ°â€çš„é¡å‹
å…§å­˜å®‰å…¨èªè¨€é¢è‡¨çš„ä¸€å€‹æŒ‘æˆ°æ˜¯ï¼Œå®ƒå€‘éœ€è¦åœç¹ç·¨è­¯å™¨èƒ½å¤ è·Ÿè¸ªçš„å…§å®¹æä¾›å¯é æ¸¬çš„ç·¨ç¨‹æ¨¡å‹ï¼Œè€Œç·¨è­¯å™¨ä¸­çš„éœæ…‹åˆ†ææœ¬è³ªä¸Šæ˜¯æœ‰é™çš„ã€‚ä¾‹å¦‚ï¼Œé›–ç„¶ç·¨è­¯å™¨å¯ä»¥ç†è§£ä¸‹é¢ç¬¬ä¸€å€‹ç¤ºä¾‹ä¸­çš„å…©å€‹æ•¸çµ„è¨ªå•æ˜¯é‡å°ä¸åŒçš„æ•¸çµ„å…ƒç´ ï¼Œä½†ï¼ˆé€šå¸¸ï¼‰ä¸å¯èƒ½æ¨ç†ç¬¬äºŒå€‹ç¤ºä¾‹ï¼ˆé€™æ˜¯ C++ ä»£ç¢¼ï¼‰ï¼š

std::pair<T, T> getValues1(MutableArray<T> &array) {
    return { std::move(array[0]), std::move(array[1]) };
}
std::pair<T, T> getValues2(MutableArray<T> &array, size_t i, size_t j) {
    return { std::move(array[i]), std::move(array[j]) };
}

é€™è£¡çš„å•é¡Œæ˜¯æ ¹æœ¬æ²’æœ‰è¾¦æ³•ï¼ˆåƒ…æŸ¥çœ‹ä¸Šé¢çš„å‡½æ•¸é«”ï¼‰çŸ¥é“æˆ–è­‰æ˜ å’Œ çš„å‹•æ…‹å€¼iä¸jç›¸åŒã€‚é›–ç„¶å¯ä»¥ç¶­è­·å‹•æ…‹ç‹€æ…‹ä¾†è·Ÿè¸ªæ•¸çµ„çš„å„å€‹å…ƒç´ æ˜¯å¦è™•æ–¼æ´»å‹•ç‹€æ…‹ï¼Œä½†é€™é€šå¸¸æœƒå°è‡´å¤§é‡çš„é‹è¡Œæ™‚é–‹éŠ·ï¼ˆå³ä½¿ä¸ä½¿ç”¨ç§»å‹•/å‚³è¼¸ï¼‰ï¼Œè€Œé€™æ˜¯ Mojo å’Œå…¶ä»–ç³»çµ±ç·¨ç¨‹èªè¨€ä¸é¡˜æ„åšçš„äº‹æƒ…ã€‚è§£æ±ºé€™å€‹å•é¡Œçš„æ–¹æ³•æœ‰å¾ˆå¤šç¨®ï¼ŒåŒ…æ‹¬ä¸€äº›ç›¸ç•¶è¤‡é›œä¸”ä¸¦ä¸ç¸½æ˜¯å®¹æ˜“å­¸ç¿’çš„è§£æ±ºæ–¹æ¡ˆã€‚

Mojo æ¡ç”¨å‹™å¯¦çš„æ–¹æ³•ï¼Œè®“ Mojo ç¨‹åºå“¡ç„¡éœ€è™•ç†å…¶é¡å‹ç³»çµ±å³å¯å®Œæˆå·¥ä½œã€‚å¦‚ä¸Šæ‰€ç¤ºï¼Œå®ƒä¸¦ä¸å¼·åˆ¶é¡å‹å¯è¤‡åˆ¶ã€å¯ç§»å‹•ï¼Œç”šè‡³å¯æ§‹é€ ï¼Œä½†å®ƒç¢ºå¯¦å¸Œæœ›é¡å‹èƒ½å¤ è¡¨é”å…¶å®Œæ•´å¥‘ç´„ï¼Œä¸¦ä¸”å®ƒå¸Œæœ›å¯¦ç¾ç¨‹åºå“¡æœŸæœ›å¾ C++ ç­‰èªè¨€ä¸­ç²å¾—çš„æµæš¢è¨­è¨ˆæ¨¡å¼ã€‚é€™è£¡ï¼ˆçœ¾æ‰€å‘¨çŸ¥çš„ï¼‰è§€å¯Ÿçµæœæ˜¯ï¼Œè¨±å¤šå°è±¡çš„å…§å®¹å¯ä»¥è¢«â€œç«Šå–â€ï¼Œè€Œç„¡éœ€ç¦ç”¨å…¶ææ§‹å‡½æ•¸ï¼Œé€™è¦ä¹ˆæ˜¯å› ç‚ºå®ƒå€‘å…·æœ‰â€œç©ºç‹€æ…‹â€ï¼ˆå¦‚å¯é¸é¡å‹æˆ–å¯ç‚ºç©ºæŒ‡é‡ï¼‰ï¼Œè¦ä¹ˆæ˜¯å› ç‚ºå®ƒå€‘å…·æœ‰å¯é«˜æ•ˆå‰µå»ºçš„ç©ºå€¼å’Œç„¡æ“ä½œéŠ·æ¯€ï¼ˆä¾‹å¦‚ï¼Œå…¶æ•¸æ“šå¯ä»¥å…·æœ‰ç©ºæŒ‡é‡ï¼‰  std::vectorã€‚

ç‚ºäº†æ”¯æŒé€™äº›ç”¨ä¾‹ï¼Œ^å‚³è¼¸é‹ç®—ç¬¦æ”¯æŒä»»æ„ LValueï¼Œä¸¦ä¸”ç•¶æ‡‰ç”¨æ–¼å…¶ä¸­æ™‚ï¼Œå®ƒæœƒèª¿ç”¨â€œç«Šå–ç§»å‹•æ§‹é€ å‡½æ•¸â€ã€‚æ­¤æ§‹é€ å‡½æ•¸å¿…é ˆå°‡æ–°å€¼è¨­ç½®ç‚ºæ´»å‹•ç‹€æ…‹ï¼Œä¸¦ä¸”å®ƒå¯ä»¥æ”¹è®ŠèˆŠå€¼ï¼Œä½†å®ƒå¿…é ˆå°‡èˆŠå€¼ç½®æ–¼å…¶ææ§‹å‡½æ•¸ä»ç„¶å¯ä»¥å·¥ä½œçš„ç‹€æ…‹ã€‚ä¾‹å¦‚ï¼Œå¦‚æœæˆ‘å€‘æƒ³å°‡æˆ‘å€‘æ”¾å…¥FileDescriptorä¸€å€‹å‘é‡ä¸­ä¸¦ç§»å‡ºå®ƒï¼Œæˆ‘å€‘å¯èƒ½æœƒé¸æ“‡æ“´å±•å®ƒä»¥çŸ¥é“å®ƒ-1æ˜¯ä¸€å€‹å“¨å…µï¼Œé€™æ„å‘³è‘—å®ƒæ˜¯â€œç©ºâ€ã€‚æˆ‘å€‘å¯ä»¥é€™æ¨£å¯¦ç¾ï¼š

# This is a simple wrapper around POSIX-style fcntl.h functions.
struct FileDescriptor:
    var fd: Int

    # This is the new key capability.
    fn __moveinit__(inout self, inout existing: Self):
        self.fd = existing.fd
        existing.fd = -1  # neutralize 'existing'.

    fn __moveinit__(inout self, owned existing: Self): # as above
    fn __init__(inout self, fd: Int): # as above
    fn __init__(inout self, path: String): # as above

    fn __del__(owned self):
        if self.fd != -1:
            close(self.fd)   # pseudo code, call close(2)

è«‹æ³¨æ„â€œç«Šå–ç§»å‹•â€æ§‹é€ å‡½æ•¸å¦‚ä½•å¾ç¾æœ‰å€¼ä¸­ç²å–æ–‡ä»¶æè¿°ç¬¦ä¸¦æ”¹è®Šè©²å€¼ï¼Œä»¥ä¾¿å…¶ææ§‹å‡½æ•¸ä¸æœƒåŸ·è¡Œä»»ä½•æ“ä½œã€‚é€™ç¨®æŠ€è¡“éœ€è¦æ¬Šè¡¡ï¼Œä¸¦ä¸æ˜¯å°æ¯ç¨®é¡å‹éƒ½æ˜¯æœ€å¥½çš„ã€‚æˆ‘å€‘å¯ä»¥çœ‹åˆ°å®ƒå‘ææ§‹å‡½æ•¸æ·»åŠ äº†ä¸€å€‹ï¼ˆå»‰åƒ¹çš„ï¼‰åˆ†æ”¯ï¼Œå› ç‚ºå®ƒå¿…é ˆæª¢æŸ¥å“¨å…µæƒ…æ³ã€‚é€šå¸¸ä¹Ÿèªç‚ºä½¿æ­¤é¡é¡å‹å¯ç‚ºç©ºæ˜¯ä¸å¥½çš„å½¢å¼ï¼Œå› ç‚ºåƒé¡å‹é€™æ¨£çš„æ›´é€šç”¨çš„åŠŸèƒ½Optional[T]æ˜¯è™•ç†é€™ç¨®æƒ…æ³çš„æ›´å¥½æ–¹æ³•ã€‚

æ­¤å¤–ï¼Œæˆ‘å€‘è¨ˆåŠƒåœ¨ Mojo æœ¬èº«ä¸­å¯¦ç¾Optional[T]ï¼Œä¸¦ä¸”Optionaléœ€è¦æ­¤åŠŸèƒ½ã€‚æˆ‘å€‘é‚„ç›¸ä¿¡ï¼Œåº«ä½œè€…æ¯”èªè¨€è¨­è¨ˆè€…æ›´äº†è§£ä»–å€‘çš„é ˜åŸŸå•é¡Œï¼Œä¸¦ä¸”é€šå¸¸æ›´é¡˜æ„è³¦äºˆåº«ä½œè€…å°è©²é ˜åŸŸçš„å…¨éƒ¨æ¬ŠåŠ›ã€‚å› æ­¤ï¼Œæ‚¨å¯ä»¥é¸æ“‡ï¼ˆä½†ä¸å¿…ï¼‰è®“æ‚¨çš„é¡å‹ä»¥é¸æ“‡åŠ å…¥çš„æ–¹å¼åƒèˆ‡æ­¤è¡Œç‚ºã€‚

å¯è¤‡åˆ¶é¡å‹
å¯ç§»å‹•é¡å‹çš„ä¸‹ä¸€æ­¥æ˜¯å¯è¤‡åˆ¶é¡å‹ã€‚å¯è¤‡åˆ¶é¡å‹ä¹Ÿå¾ˆå¸¸è¦‹ - ç¨‹åºå“¡é€šå¸¸æœŸæœ›å­—ç¬¦ä¸²å’Œæ•¸çµ„ä¹‹é¡çš„æ±è¥¿æ˜¯å¯è¤‡åˆ¶çš„ï¼Œä¸¦ä¸”æ¯å€‹ Python å°è±¡å¼•ç”¨éƒ½æ˜¯å¯è¤‡åˆ¶çš„ - é€šéè¤‡è£½æŒ‡é‡å’Œèª¿æ•´å¼•ç”¨è¨ˆæ•¸ã€‚

æœ‰å¾ˆå¤šæ–¹æ³•å¯ä»¥å¯¦ç¾å¯è¤‡åˆ¶é¡å‹ã€‚ä¸€ç¨®å¯ä»¥å¯¦ç¾åƒ Python æˆ– Java é€™æ¨£çš„å¼•ç”¨èªç¾©é¡å‹ï¼Œåœ¨å…¶ä¸­å‚³æ’­å…±äº«æŒ‡é‡ï¼Œä¸€ç¨®å¯ä»¥ä½¿ç”¨æ˜“æ–¼å…±äº«çš„ä¸å¯è®Šæ•¸æ“šçµæ§‹ï¼Œå› ç‚ºå®ƒå€‘ä¸€æ—¦å‰µå»ºå°±ä¸æœƒç™¼ç”Ÿè®ŠåŒ–ï¼Œä¸€ç¨®å¯ä»¥åƒ Swift é‚£æ¨£é€šéæƒ°æ€§å¯«å…¥æ™‚å¾©åˆ¶ä¾†å¯¦ç¾æ·±å±¤å€¼èªç¾©ã€‚é€™äº›æ–¹æ³•ä¸­çš„æ¯ä¸€ç¨®éƒ½æœ‰ä¸åŒçš„æ¬Šè¡¡ï¼ŒMojo èªç‚ºï¼Œé›–ç„¶æˆ‘å€‘éœ€è¦ä¸€äº›é€šç”¨çš„é›†åˆé¡å‹é›†ï¼Œä½†æˆ‘å€‘ä¹Ÿå¯ä»¥æ”¯æŒå»£æ³›çš„å°ˆæ³¨æ–¼ç‰¹å®šç”¨ä¾‹çš„å°ˆç”¨é›†åˆé¡å‹ã€‚

åœ¨ Mojo ä¸­ï¼Œæ‚¨å¯ä»¥é€šéå¯¦ç¾è©²__copyinit__æ–¹æ³•ä¾†åšåˆ°é€™ä¸€é»ã€‚é€™æ˜¯ä½¿ç”¨ç°¡å–®çš„ç¤ºä¾‹Stringï¼ˆå½ä»£ç¢¼ï¼‰ï¼š

struct MyString:
    var data: Pointer[UI8]

    # StringRef is a pointer + length and works with StringLiteral.
    def __init__(inout self, input: StringRef):
        self.data = ...

    # Copy the string by deep copying the underlying malloc'd data.
    def __copyinit__(inout self, existing: Self):
        self.data = strdup(existing.data)

    # This isn't required, but optimizes unneeded copies.
    def __moveinit__(inout self, owned existing: Self):
        self.data = existing.data

    def __del__(owned self):
        free(self.data.address)

    def __add__(self, rhs: MyString) -> MyString: ...

é€™å€‹ç°¡å–®é¡å‹æ˜¯ä¸€å€‹æŒ‡å‘ç”¨ malloc åˆ†é…çš„â€œç©ºçµ‚æ­¢â€å­—ç¬¦ä¸²æ•¸æ“šçš„æŒ‡é‡ï¼Œç‚ºæ¸…æ¥šèµ·è¦‹ï¼Œä½¿ç”¨è€å¼ C APIã€‚å®ƒå¯¦ç¾äº†__copyinit__ï¼Œå®ƒç¶­è­·äº†æ¯å€‹ å¯¦ä¾‹éƒ½æ“æœ‰å…¶åº•å±¤æŒ‡é‡ä¸¦åœ¨éŠ·æ¯€æ™‚é‡‹æ”¾å®ƒçš„ä¸è®Šå¼MyStringã€‚é€™å€‹å¯¦ç¾å»ºç«‹åœ¨æˆ‘å€‘ä¸Šé¢çœ‹åˆ°çš„æŠ€å·§çš„åŸºç¤ä¸Šï¼Œä¸¦å¯¦ç¾äº†ä¸€å€‹__moveinit__æ§‹é€ å‡½æ•¸ï¼Œé€™ä½¿å¾—å®ƒå¯ä»¥åœ¨æŸäº›å¸¸è¦‹æƒ…æ³ä¸‹å®Œå…¨æ¶ˆé™¤è‡¨æ™‚å‰¯æœ¬ã€‚æ‚¨å¯ä»¥åœ¨æ­¤ä»£ç¢¼åºåˆ—ä¸­çœ‹åˆ°æ­¤è¡Œç‚ºï¼š

fn test_my_string():
    var s1 = MyString("hello ")

    var s2 = s1    # s2.__copyinit__(s1) runs here

    print(s1)

    var s3 = s1^   # s3.__moveinit__(s1) runs here

    print(s2)
    # s2.__del__() runs here
    print(s3)
    # s3.__del__() runs here

åœ¨é€™ç¨®æƒ…æ³ä¸‹ï¼Œæ‚¨å¯ä»¥æ˜ç™½ç‚ºä»€éº¼éœ€è¦å¾©åˆ¶æ§‹é€ å‡½æ•¸ï¼šå¦‚æœæ²’æœ‰å¾©åˆ¶æ§‹é€ å‡½æ•¸ï¼Œå°‡å€¼è¤‡è£½s1åˆ°s2å°‡æ˜¯ä¸€å€‹éŒ¯èª¤ - å› ç‚ºæ‚¨ä¸èƒ½æ“æœ‰åŒä¸€ä¸å¯è¤‡åˆ¶é¡å‹çš„å…©å€‹å¯¦æ™‚å¯¦ä¾‹ã€‚ç§»å‹•æ§‹é€ å‡½æ•¸æ˜¯å¯é¸çš„ï¼Œä½†æœ‰åŠ©æ–¼åˆ†é…åˆ°s3ï¼šæ²’æœ‰å®ƒï¼Œç·¨è­¯å™¨å°‡å¾ s1 èª¿ç”¨è¤‡åˆ¶æ§‹é€ å‡½æ•¸ï¼Œç„¶å¾ŒéŠ·æ¯€èˆŠs1å¯¦ä¾‹ã€‚é€™åœ¨é‚è¼¯ä¸Šæ˜¯æ­£ç¢ºçš„ï¼Œä½†æœƒå¸¶ä¾†é¡å¤–çš„é‹è¡Œæ™‚é–‹éŠ·ã€‚

Mojo æœƒæ€¥åˆ‡åœ°éŠ·æ¯€å€¼ï¼Œé€™ä½¿å¾—å®ƒèƒ½å¤ å°‡å¾©åˆ¶+éŠ·æ¯€å°è½‰æ›ç‚ºå–®å€‹ç§»å‹•æ“ä½œï¼Œé€™å¯ä»¥å¸¶ä¾†æ¯” C++ æ›´å¥½çš„æ€§èƒ½ï¼Œè€Œä¸éœ€è¦å°std::move.

ç‘£ç¢é¡å‹
æœ€éˆæ´»çš„é¡å‹å°±æ˜¯â€œæ¯”ç‰¹è¢‹â€ã€‚é€™äº›é¡å‹æ˜¯â€œå¾®ä¸è¶³é“çš„â€ï¼Œå› ç‚ºå®ƒå€‘å¯ä»¥è¢«è¤‡è£½ã€ç§»å‹•å’ŒéŠ·æ¯€ï¼Œè€Œç„¡éœ€èª¿ç”¨è‡ªå®šç¾©ä»£ç¢¼ã€‚åƒé€™æ¨£çš„é¡å‹å¯ä»¥èªªæ˜¯æˆ‘å€‘å‘¨åœæœ€å¸¸è¦‹çš„åŸºæœ¬é¡å‹ï¼šåƒæ•´æ•¸å’Œæµ®é»å€¼é€™æ¨£çš„æ±è¥¿éƒ½æ˜¯å¾®ä¸è¶³é“çš„ã€‚å¾èªè¨€çš„è§’åº¦ä¾†çœ‹ï¼ŒMojo ä¸éœ€è¦å°é€™äº›é€²è¡Œç‰¹æ®Šæ”¯æŒï¼Œé¡å‹ä½œè€…å°‡é€™äº›æ±è¥¿å¯¦ç¾ç‚ºç„¡æ“ä½œä¸¦å…è¨±å…§è¯å™¨è®“å®ƒå€‘æ¶ˆå¤±æ˜¯å®Œå…¨å¯ä»¥çš„ã€‚

é€™ç¨®æ–¹æ³•ä¸æ˜¯æœ€ç†æƒ³çš„æœ‰å…©å€‹åŸå› ï¼šä¸€æ˜¯æˆ‘å€‘ä¸å¸Œæœ›åœ¨ç°¡å–®é¡å‹ä¸Šå®šç¾©ä¸€å †æ–¹æ³•çš„æ¨£æ¿ï¼ŒäºŒæ˜¯æˆ‘å€‘ä¸å¸Œæœ›ç”Ÿæˆå’Œæ¨é€ä¸€å †å‡½æ•¸èª¿ç”¨çš„ç·¨è­¯æ™‚é–‹éŠ·ï¼Œåªæ˜¯è®“å®ƒå€‘å…§è¯åˆ°ä»€éº¼éƒ½æ²’æœ‰ã€‚æ­¤å¤–ï¼Œé‚„å­˜åœ¨ä¸€å€‹æ­£äº¤å•é¡Œï¼Œå³è¨±å¤šé¡å‹åœ¨å¦ä¸€ç¨®æ„ç¾©ä¸Šæ˜¯å¾®ä¸è¶³é“çš„ï¼šå®ƒå€‘å¾ˆå°ï¼Œæ‡‰è©²åœ¨ CPU çš„å¯„å­˜å™¨ä¸­å‚³éï¼Œè€Œä¸æ˜¯é–“æ¥åœ¨å…§å­˜ä¸­å‚³éã€‚

å› æ­¤ï¼ŒMojo æä¾›äº†ä¸€å€‹çµæ§‹è£é£¾å™¨ä¾†è§£æ±ºæ‰€æœ‰é€™äº›å•é¡Œã€‚æ‚¨å¯ä»¥ä½¿ç”¨è£é£¾å™¨å¯¦ç¾é¡å‹@register_passable("trivial")ï¼Œé€™å‘Šè¨´ Mojo è©²é¡å‹æ‡‰è©²æ˜¯å¯è¤‡åˆ¶å’Œå¯ç§»å‹•çš„ï¼Œä½†å®ƒæ²’æœ‰ç”¨æˆ¶å®šç¾©çš„é‚è¼¯ä¾†åŸ·è¡Œæ­¤æ“ä½œã€‚å®ƒé‚„å‘Šè¨´ Mojo æ›´å–œæ­¡å‚³é CPU å¯„å­˜å™¨ä¸­çš„å€¼ï¼Œé€™å¯ä»¥å¸¶ä¾†æ•ˆç‡å„ªå‹¢ã€‚

TODOï¼šé€™å€‹è£é£¾å™¨éœ€è¦é‡æ–°è€ƒæ…®ã€‚ç¼ºä¹è‡ªå®šç¾©é‚è¼¯è¤‡è£½/ç§»å‹•/éŠ·æ¯€é‚è¼¯å’Œâ€œå¯„å­˜å™¨ä¸­çš„å¯å‚³éæ€§â€æ˜¯æ­£äº¤çš„å•é¡Œï¼Œæ‡‰è©²åˆ†é–‹ã€‚å‰é¢çš„é‚è¼¯æ‡‰è©²åŒ…å«åœ¨ä¸€å€‹æ›´é€šç”¨çš„@value("trivial")è£é£¾å™¨ä¸­ï¼Œå®ƒèˆ‡ æ­£äº¤@register_passableã€‚

@valueè£é£¾è€…
Mojo çš„åƒ¹å€¼ç”Ÿå‘½é€±æœŸæä¾›äº†ç°¡å–®ä¸”å¯é æ¸¬çš„é‰¤å­ï¼Œä½¿æ‚¨èƒ½å¤ æ­£ç¢ºè¡¨é”ç•°åœ‹æƒ…èª¿çš„ä½ç´šäº‹ç‰©Atomicã€‚é€™å°æ–¼æ§åˆ¶å’Œç°¡å–®çš„ç·¨ç¨‹æ¨¡å‹ä¾†èªªéå¸¸æœ‰ç”¨ï¼Œä½†å¤§å¤šæ•¸çµæ§‹éƒ½æ˜¯å…¶ä»–é¡å‹çš„ç°¡å–®èšåˆï¼Œæˆ‘å€‘ä¸æƒ³ç‚ºå®ƒå€‘ç·¨å¯«å¤§é‡æ¨£æ¿æ–‡ä»¶ã€‚ç‚ºäº†è§£æ±ºé€™å€‹å•é¡Œï¼ŒMojo æä¾›äº†ä¸€å€‹@valueçµæ§‹è£é£¾å™¨ï¼Œå¯ä»¥ç‚ºæ‚¨åˆæˆå¤§é‡æ¨£æ¿æ–‡ä»¶ã€‚

æ‚¨å¯ä»¥å°‡å…¶è¦–ç‚º@valuePython çš„æ“´å±•@dataclassï¼Œå®ƒé‚„å¯ä»¥è™•ç† Mojo__moveinit__å’Œ__copyinit__æ–¹æ³•ã€‚

è£é£¾@valueå™¨æœƒæŸ¥çœ‹æ‚¨é¡å‹çš„å­—æ®µï¼Œä¸¦ç”Ÿæˆä¸€äº›ç¼ºå°‘çš„æˆå“¡ã€‚ä¾‹å¦‚ï¼Œè€ƒæ…®é€™æ¨£ä¸€å€‹ç°¡å–®çš„çµæ§‹ï¼š

from String import String

@value
struct MyPet:
    var name: String
    var age: Int

Mojo æœƒæ³¨æ„åˆ°æ‚¨æ²’æœ‰æˆå“¡åˆå§‹åŒ–å™¨ã€ç§»å‹•æ§‹é€ å‡½æ•¸æˆ–è¤‡åˆ¶æ§‹é€ å‡½æ•¸ï¼Œå®ƒæœƒç‚ºæ‚¨åˆæˆé€™äº›ï¼Œå°±åƒæ‚¨ç·¨å¯«çš„ä¸€æ¨£ï¼š

struct MyPet:
    var name: String
    var age: Int

    fn __init__(inout self, owned name: String, age: Int):
        self.name = name^
        self.age = age

    fn __copyinit__(inout self, existing: Self):
        self.name = existing.name
        self.age = existing.age

    fn __moveinit__(inout self, owned existing: Self):
        self.name = existing.name^
        self.age = existing.age

ç•¶æ‚¨æ·»åŠ @valueè£é£¾å™¨æ™‚ï¼ŒMojo åƒ…ç•¶é€™äº›ç‰¹æ®Šæ–¹æ³•ä¸å­˜åœ¨æ™‚æ‰æœƒåˆæˆå®ƒå€‘ã€‚æ‚¨å¯ä»¥é€šéå®šç¾©è‡ªå·±çš„ç‰ˆæœ¬ä¾†è¦†è“‹ä¸€å€‹æˆ–å¤šå€‹ç‰ˆæœ¬çš„è¡Œç‚ºã€‚ä¾‹å¦‚ï¼Œæƒ³è¦è‡ªå®šç¾©å¾©åˆ¶æ§‹é€ å‡½æ•¸ä½†ä½¿ç”¨é»˜èªçš„æˆå“¡æ–¹å¼å’Œç§»å‹•æ§‹é€ å‡½æ•¸æ˜¯ç›¸ç•¶å¸¸è¦‹çš„ã€‚

ç”±æ–¼çµæ§‹å–å¾—æ‰€æœ‰æ¬Šä¸¦å­˜å„²å€¼ï¼Œå› æ­¤ çš„åƒæ•¸__init__å…¨éƒ¨ä½œç‚ºåƒæ•¸å‚³éã€‚ownedé€™æ˜¯ä¸€å€‹æœ‰ç”¨çš„å¾®è§€å„ªåŒ–ï¼Œå¯ä»¥ä½¿ç”¨åƒ…ç§»å‹•é¡å‹ã€‚åƒé€™æ¨£çš„ç°¡å–®é¡å‹Intä¹Ÿå¯ä»¥ä½œç‚ºè‡ªæœ‰å€¼å‚³éï¼Œä½†ç”±æ–¼é€™å°å®ƒå€‘ä¾†èªªæ²’æœ‰ä»»ä½•æ„ç¾©ï¼Œå› æ­¤^ç‚ºäº†æ¸…æ¥šèµ·è¦‹ï¼Œæˆ‘å€‘çœç•¥äº†æ¨™è¨˜å’Œå‚³è¼¸é‹ç®—ç¬¦ ( )ã€‚

æ³¨æ„ï¼šå¦‚æœæ‚¨çš„é¡å‹åŒ…å«ä»»ä½•åƒ…ç§»å‹•å­—æ®µï¼ŒMojo å°‡ä¸æœƒç”Ÿæˆè¤‡åˆ¶æ§‹é€ å‡½æ•¸ï¼Œå› ç‚ºå®ƒç„¡æ³•è¤‡è£½é€™äº›å­—æ®µã€‚æ­¤å¤–ï¼Œ@valueè£é£¾å™¨åƒ…é©ç”¨æ–¼å…¶æˆå“¡å¯è¤‡åˆ¶å’Œ/æˆ–å¯ç§»å‹•çš„é¡å‹ã€‚å¦‚æœæ‚¨Atomicçš„çµæ§‹ä¸­æœ‰é¡ä¼¼çš„å…§å®¹ï¼Œé‚£éº¼å®ƒå¯èƒ½ä¸æ˜¯å€¼é¡å‹ï¼Œä¸¦ä¸”æ‚¨ç„¡è«–å¦‚ä½•éƒ½ä¸æƒ³è¦é€™äº›æˆå“¡ã€‚

å¦è«‹æ³¨æ„ï¼ŒMyPetä¸Šé¢çš„çµæ§‹ä¸åŒ…æ‹¬__del__()ææ§‹å‡½æ•¸ - Mojo ä¹Ÿç¶œåˆäº†å®ƒï¼Œä½†å®ƒä¸éœ€è¦è£é£¾å™¨ï¼ˆè«‹åƒé–±ä¸‹é¢æœ‰é—œææ§‹å‡½æ•¸@valueçš„éƒ¨åˆ†ï¼‰ã€‚

æ­¤æ™‚æ²’æœ‰è¾¦æ³•æŠ‘åˆ¶ç‰¹å®šæ–¹æ³•çš„ç”Ÿæˆæˆ–è‡ªå®šç¾©ç”Ÿæˆï¼Œä½†@valueå¦‚æœæœ‰éœ€æ±‚ï¼Œæˆ‘å€‘å¯ä»¥å‘ç”Ÿæˆå™¨æ·»åŠ åƒæ•¸ä¾†åŸ·è¡Œæ­¤æ“ä½œã€‚

ç”±æ–¼çµæ§‹å–å¾—æ‰€æœ‰æ¬Šä¸¦å­˜å„²å€¼ï¼Œå› æ­¤ çš„åƒæ•¸__init__å…¨éƒ¨ä½œç‚ºåƒæ•¸å‚³éã€‚ownedé€™æ˜¯ä¸€å€‹æœ‰ç”¨çš„å¾®è§€å„ªåŒ–ï¼Œå¯ä»¥ä½¿ç”¨åƒ…ç§»å‹•é¡å‹ã€‚åƒé€™æ¨£çš„ç°¡å–®é¡å‹Intä¹Ÿå¯ä»¥ä½œç‚ºè‡ªæœ‰å€¼å‚³éï¼Œä½†ç”±æ–¼é€™å°å®ƒå€‘ä¾†èªªæ²’æœ‰ä»»ä½•æ„ç¾©ï¼Œå› æ­¤^ç‚ºäº†æ¸…æ¥šèµ·è¦‹ï¼Œæˆ‘å€‘çœç•¥äº†æ¨™è¨˜å’Œå‚³è¼¸é‹ç®—ç¬¦ ( )ã€‚

ææ§‹å‡½æ•¸çš„è¡Œç‚º
Mojo ä¸­çš„ä»»ä½•çµæ§‹éƒ½å¯ä»¥æœ‰ä¸€å€‹ææ§‹å‡½æ•¸ï¼ˆä¸€ç¨®__del__()æ–¹æ³•ï¼‰ï¼Œè©²ææ§‹å‡½æ•¸æœƒåœ¨å€¼çš„ç”Ÿå‘½é€±æœŸçµæŸæ™‚ï¼ˆé€šå¸¸æ˜¯æœ€å¾Œä½¿ç”¨è©²å€¼çš„æ™‚é–“é»ï¼‰è‡ªå‹•é‹è¡Œã€‚ä¾‹å¦‚ï¼Œä¸€å€‹ç°¡å–®çš„å­—ç¬¦ä¸²å¯èƒ½å¦‚ä¸‹æ‰€ç¤ºï¼ˆå½ä»£ç¢¼ï¼‰ï¼š

@value
struct MyString:
    var data: Pointer[UInt8]

    def __init__(inout self, input: StringRef): ...
    def __add__(self, rhs: String) -> MyString: ...
    def __del__(owned self):
        free(self.data.address)

Mojoä½¿ç”¨æ¯æ¬¡èª¿ç”¨å¾Œé‹è¡Œçš„â€œç›¡å¿«â€MyString (ASAP) ç­–ç•¥ä¾†éŠ·æ¯€è«¸å¦‚ï¼ˆå®ƒèª¿ç”¨ææ§‹å‡½æ•¸ï¼‰ä¹‹é¡çš„å€¼ã€‚Mojo ä¸æœƒç­‰åˆ°ä»£ç¢¼å¡ŠçµæŸæ™‚æ‰éŠ·æ¯€æœªä½¿ç”¨çš„å€¼ã€‚å³ä½¿åœ¨åƒé€™æ¨£çš„è¡¨é”å¼ä¸­ï¼Œä¸€æ—¦ä¸å†éœ€è¦ä¸­é–“è¡¨é”å¼ï¼ŒMojo å°±æœƒç«‹å³éŠ·æ¯€å®ƒå€‘ï¼Œè€Œä¸æœƒç­‰åˆ°èªå¥çµæŸã€‚__del__()a+b+c+d

ç•¶å€¼å¤±æ•ˆæ™‚ï¼ŒMojo ç·¨è­¯å™¨æœƒè‡ªå‹•èª¿ç”¨ææ§‹å‡½æ•¸ï¼Œä¸¦ç‚ºææ§‹å‡½æ•¸ä½•æ™‚é‹è¡Œæä¾›å¼·æœ‰åŠ›çš„ä¿è­‰ã€‚Mojo ä½¿ç”¨éœæ…‹ç·¨è­¯å™¨åˆ†æä¾†æ¨ç†ä»£ç¢¼ä¸¦æ±ºå®šä½•æ™‚æ’å…¥å°ææ§‹å‡½æ•¸çš„èª¿ç”¨ã€‚ä¾‹å¦‚ï¼š

fn use_strings():
    var a = String("hello a")
    let b = String("hello b")
    print(a)
    # a.__del__() runs here for "hello a"


    print(b)
    # b.__del__() runs here

    a = String("temporary a")
    # a.__del__() runs here because "temporary a" is never used

    # Other stuff happens here

    a = String("final a")
    print(a)
    # a.__del__() runs again here for "final a"

use_strings()

hello a
hello b
final a
åœ¨ä¸Šé¢çš„ä»£ç¢¼ä¸­ï¼Œæ‚¨å°‡çœ‹åˆ° å’Œaå€¼bæ˜¯åœ¨æ—©æœŸå‰µå»ºçš„ï¼Œä¸¦ä¸”å€¼çš„æ¯å€‹åˆå§‹åŒ–éƒ½èˆ‡å°ææ§‹å‡½æ•¸çš„èª¿ç”¨ç›¸åŒ¹é…ã€‚è«‹æ³¨æ„ï¼Œå®ƒaæœƒè¢«å¤šæ¬¡éŠ·æ¯€â€”â€”æ¯æ¬¡æ”¶åˆ°æ–°å€¼æ™‚éƒ½æœƒè¢«éŠ·æ¯€ä¸€æ¬¡ã€‚

ç¾åœ¨ï¼Œé€™å¯èƒ½æœƒè®“ C++ ç¨‹åºå“¡æ„Ÿåˆ°é©šè¨ï¼Œå› ç‚ºå®ƒèˆ‡RAII æ¨¡å¼ä¸åŒï¼Œåœ¨ RAII æ¨¡å¼ä¸­ï¼ŒC++ åœ¨ä½œç”¨åŸŸæœ«å°¾éŠ·æ¯€å€¼ã€‚Mojo é‚„éµå¾ªé€™æ¨£çš„åŸå‰‡ï¼šå€¼åœ¨æ§‹é€ å‡½æ•¸ä¸­ç²å–è³‡æºä¸¦åœ¨ææ§‹å‡½æ•¸ä¸­é‡‹æ”¾è³‡æºï¼Œä½† Mojo ä¸­çš„æ€¥åˆ‡éŠ·æ¯€æ¯” C++ ä¸­åŸºæ–¼ç¯„åœçš„éŠ·æ¯€å…·æœ‰è¨±å¤šå¼·å¤§çš„å„ªå‹¢ï¼š

Mojo æ–¹æ³•æ¶ˆé™¤äº†é¡å‹å¯¦ç¾é‡æ–°è³¦å€¼é‹ç®—ç¬¦çš„éœ€è¦ï¼Œä¾‹å¦‚C++ ä¸­çš„operator=(const T&)and operator=(T&&)ï¼Œå¾è€Œæ›´å®¹æ˜“å®šç¾©é¡å‹ä¸¦æ¶ˆé™¤æ¦‚å¿µã€‚

Mojo ä¸å…è¨±å¯è®Šå¼•ç”¨èˆ‡å…¶ä»–å¯è®Šå¼•ç”¨æˆ–ä¸å¯è®Šå€Ÿç”¨é‡ç–Šã€‚å®ƒæä¾›å¯é æ¸¬ç·¨ç¨‹æ¨¡å‹çš„ä¸€å€‹ä¸»è¦æ–¹æ³•æ˜¯ç¢ºä¿å°å°è±¡çš„å¼•ç”¨ç›¡å¿«æ¶ˆå¤±ï¼Œé¿å…ç·¨è­¯å™¨èªç‚ºä¸€å€‹å€¼å¯èƒ½ä»ç„¶å­˜åœ¨ä¸¦å¹²æ“¾å¦ä¸€å€‹å€¼çš„æ··äº‚æƒ…æ³ï¼Œä½†ç”¨æˆ¶å°æ­¤ä¸¦ä¸æ¸…æ¥šã€‚

åœ¨æœ€å¾Œä½¿ç”¨æ™‚éŠ·æ¯€å€¼èˆ‡â€œç§»å‹•â€å„ªåŒ–å¾ˆå¥½åœ°çµåˆåœ¨ä¸€èµ·ï¼Œå®ƒå°‡â€œè¤‡è£½+åˆªé™¤â€å°è½‰æ›ç‚ºâ€œç§»å‹•â€æ“ä½œï¼Œé€™æ˜¯ C++ ç§»å‹•å„ªåŒ–ï¼ˆå¦‚ NRVOï¼‰çš„æ¨å»£ï¼ˆç¨±ç‚ºè¿”å›å€¼å„ªåŒ–ï¼‰ã€‚

å°æ–¼æŸäº›å¸¸è¦‹æ¨¡å¼ï¼ˆä¾‹å¦‚å°¾éæ­¸ï¼‰ï¼Œåœ¨ C++ ä¸­éŠ·æ¯€ä½œç”¨åŸŸæœ«å°¾çš„å€¼æ˜¯æœ‰å•é¡Œçš„ï¼Œå› ç‚ºææ§‹å‡½æ•¸èª¿ç”¨ç™¼ç”Ÿåœ¨å°¾èª¿ç”¨ä¹‹å¾Œã€‚å°æ–¼æŸäº›å‡½æ•¸å¼ç·¨ç¨‹æ¨¡å¼ä¾†èªªï¼Œé€™å¯èƒ½æ˜¯ä¸€å€‹é‡å¤§çš„æ€§èƒ½å’Œå…§å­˜å•é¡Œã€‚

é‡è¦çš„æ˜¯ï¼ŒMojo çš„å³æ™‚éŠ·æ¯€åœ¨ Python é¢¨æ ¼çš„defå‡½æ•¸ä¸­ä¹Ÿèƒ½å¾ˆå¥½åœ°å·¥ä½œï¼Œä»¥åœ¨ç´°ç²’åº¦ç´šåˆ¥æä¾›éŠ·æ¯€ä¿è­‰ï¼ˆç„¡éœ€åƒåœ¾æ”¶é›†å™¨ï¼‰â€”â€”å›æƒ³ä¸€ä¸‹ï¼ŒPython ä¸¦ä¸çœŸæ­£æä¾›è¶…å‡ºå‡½æ•¸çš„ä½œç”¨åŸŸï¼Œå› æ­¤ Mojo ä¸­çš„ C++ é¢¨æ ¼éŠ·æ¯€çš„ç”¨è™•è¦å°å¾—å¤šã€‚

æ³¨æ„ï¼š Mojo é‚„æ”¯æŒ Python é¢¨æ ¼çš„withèªå¥ï¼Œå®ƒæä¾›äº†å°è³‡æºæ›´æœ‰æ„ç¯„åœçš„è¨ªå•ã€‚

Mojo æ–¹æ³•èˆ‡ Rust å’Œ Swift çš„å·¥ä½œæ–¹å¼æ›´ç›¸ä¼¼ï¼Œå› ç‚ºå®ƒå€‘éƒ½å…·æœ‰å¼·å¤§çš„åƒ¹å€¼æ‰€æœ‰æ¬Šè·Ÿè¸ªä¸¦æä¾›å…§å­˜å®‰å…¨ã€‚ä¸€å€‹å€åˆ¥æ˜¯å®ƒå€‘çš„å¯¦ç¾éœ€è¦ä½¿ç”¨å‹•æ…‹â€œæ”¾ç½®æ¨™èªŒâ€ â€”â€”å®ƒå€‘ç¶­è­·éš±è—çš„å½±å­è®Šé‡ä¾†è·Ÿè¸ªå€¼çš„ç‹€æ…‹ä»¥æä¾›å®‰å…¨æ€§ã€‚é€™äº›é€šå¸¸æœƒè¢«å„ªåŒ–æ‰ï¼Œä½† Mojo æ–¹æ³•å®Œå…¨æ¶ˆé™¤äº†é€™ç¨®é–‹éŠ·ï¼Œä½¿ç”Ÿæˆçš„ä»£ç¢¼æ›´å¿«ä¸¦é¿å…æ­§ç¾©ã€‚

ç¾å ´æ•æ„Ÿçš„ç”Ÿå‘½é€±æœŸç®¡ç†
Mojo çš„ç”Ÿå‘½é€±æœŸåˆ†æé™¤äº†å®Œå…¨æ§åˆ¶æµæ„ŸçŸ¥ä¹‹å¤–ï¼Œå®ƒé‚„å®Œå…¨å­—æ®µæ•æ„Ÿï¼ˆçµæ§‹çš„æ¯å€‹å­—æ®µéƒ½æ˜¯ç¨ç«‹è·Ÿè¸ªçš„ï¼‰ã€‚ä¹Ÿå°±æ˜¯èªªï¼ŒMojo å–®ç¨è·Ÿè¸ªâ€œæ•´å€‹å°è±¡â€æ˜¯å®Œå…¨é‚„æ˜¯åƒ…éƒ¨åˆ†åˆå§‹åŒ–/éŠ·æ¯€ã€‚

ä¾‹å¦‚ï¼Œè€ƒæ…®ä»¥ä¸‹ä»£ç¢¼ï¼š

@value
struct TwoStrings:
    var str1: String
    var str2: String

fn use_two_strings():
    var ts = TwoStrings("foo", "bar")
    print(ts.str1)
    # ts.str1.__del__() runs here

    # Other stuff happens here

    ts.str1 = String("hello") # Overwrite ts.str1
    print(ts.str1)
    # ts.__del__() runs here

use_two_strings()

foo
hello
è«‹æ³¨æ„ï¼Œè©²ts.str1å­—æ®µå¹¾ä¹ç«‹å³è¢«éŠ·æ¯€ï¼Œå› ç‚º Mojo çŸ¥é“å®ƒå°‡è¢«ä¸‹é¢è¦†è“‹ã€‚æ‚¨é‚„å¯ä»¥åœ¨ä½¿ç”¨è½‰ç§»é‹ç®—ç¬¦æ™‚çœ‹åˆ°é€™ä¸€é»ï¼Œä¾‹å¦‚ï¼š

fn consume(owned arg: String):
    pass

fn use(arg: TwoStrings):
    print(arg.str1)

fn consume_and_use_two_strings():
    var ts = TwoStrings("foo", "bar")
    consume(ts.str1^)
    # ts.str1.__moveinit__() runs here

    # ts is now only partially initialized here!

    ts.str1 = String("hello")  # All together now
    use(ts)                    # This is ok
    # ts.__del__() runs here

consume_and_use_two_strings()

hello
è«‹æ³¨æ„ï¼Œä»£ç¢¼è½‰ç§»äº†è©²str1å­—æ®µçš„æ‰€æœ‰æ¬Šï¼šåœ¨ çš„æŒçºŒæ™‚é–“å…§other_stuff()ï¼Œè©²str1å­—æ®µå®Œå…¨æœªåˆå§‹åŒ–ï¼Œå› ç‚ºæ‰€æœ‰æ¬Šå·²è½‰ç§»åˆ°consume()ã€‚ç„¶å¾Œstr1åœ¨è¢«use()å‡½æ•¸ä½¿ç”¨ä¹‹å‰é‡æ–°åˆå§‹åŒ–ï¼ˆå¦‚æœä¸æ˜¯ï¼ŒMojo æœƒæ‹’çµ•ä»£ç¢¼ä¸¦é¡¯ç¤ºæœªåˆå§‹åŒ–å­—æ®µéŒ¯èª¤ï¼‰ã€‚

Mojo å°æ­¤çš„è¦å‰‡éå¸¸å¼·å¤§ä¸”æœ‰æ„ç›´æ¥ï¼šå­—æ®µå¯ä»¥è‡¨æ™‚è½‰ç§»ï¼Œä½†â€œæ•´å€‹å°è±¡â€å¿…é ˆä½¿ç”¨èšåˆé¡å‹çš„åˆå§‹å€¼è¨­å®šé …æ§‹é€ ä¸¦ä½¿ç”¨èšåˆææ§‹å‡½æ•¸éŠ·æ¯€ã€‚é€™æ„å‘³è‘—ä¸å¯èƒ½é€šéåƒ…åˆå§‹åŒ–å…¶å­—æ®µä¾†å‰µå»ºå°è±¡ï¼Œä¹Ÿä¸å¯èƒ½é€šéåƒ…éŠ·æ¯€å…¶å­—æ®µä¾†æ‹†é™¤å°è±¡ã€‚ä¾‹å¦‚ï¼Œä»¥ä¸‹ä»£ç¢¼ç„¡æ³•ç·¨è­¯ï¼š

fn consume_and_use_two_strings():
    let ts = TwoStrings("foo", "bar") # ts is initialized
    # Uncomment to see an error:
    # consume(ts.str1^)
    # Because `ts` is not used anymore, it should be destroyed here, but
    # the object is not whole, preventing the overall value from being destroyed

    let ts2 : TwoStrings # ts2 type is declared but not initialized
    ts2.str1 = String("foo")
    ts2.str2 = String("bar")  # Both the member are initalized
    # Uncomment to see an error:
    # use(ts2) # Error: 'ts2' isn't fully initialized

é›–ç„¶æˆ‘å€‘å¯ä»¥å…è¨±é€™æ¨£çš„æ¨¡å¼ç™¼ç”Ÿï¼Œä½†æˆ‘å€‘æ‹’çµ•é€™ç¨®æƒ…æ³ï¼Œå› ç‚ºå€¼ä¸åƒ…åƒ…æ˜¯å…¶å„éƒ¨åˆ†çš„ç¸½å’Œã€‚è€ƒæ…®FileDescriptoråŒ…å« POSIX æ–‡ä»¶æè¿°ç¬¦ä½œç‚ºæ•´æ•¸å€¼çš„ a ï¼šéŠ·æ¯€æ•´æ•¸ï¼ˆç„¡æ“ä½œï¼‰å’ŒéŠ·æ¯€FileDescriptorï¼ˆå¯èƒ½èª¿ç”¨close()ç³»çµ±èª¿ç”¨ï¼‰ä¹‹é–“å­˜åœ¨å¾ˆå¤§å·®ç•°ã€‚å› æ­¤ï¼Œæˆ‘å€‘è¦æ±‚æ‰€æœ‰å…¨å€¼åˆå§‹åŒ–éƒ½ç¶“éåˆå§‹å€¼è¨­å®šé …ä¸¦ç”¨å…¶å…¨å€¼ææ§‹å‡½æ•¸éŠ·æ¯€ã€‚

å°±å…¶åƒ¹å€¼è€Œè¨€ï¼ŒMojo å…§éƒ¨ç¢ºå¯¦å…·æœ‰èˆ‡ Rust å‡½æ•¸ç­‰æ•ˆçš„mem::forgetåŠŸèƒ½ï¼Œå®ƒé¡¯å¼ç¦ç”¨ææ§‹å‡½æ•¸ï¼Œä¸¦å…·æœ‰ç”¨æ–¼â€œç¥ç¦â€å°è±¡çš„ç›¸æ‡‰å…§éƒ¨åŠŸèƒ½ï¼Œä½†æ­¤æ™‚å®ƒå€‘å°šæœªå…¬é–‹ä¾›ç”¨æˆ¶ä½¿ç”¨ã€‚

ç¾å ´å£½å‘½__init__
æ–¹æ³•çš„è¡Œç‚º__init__å¹¾ä¹èˆ‡ä»»ä½•å…¶ä»–æ–¹æ³•ä¸€æ¨£ - æœ‰ä¸€é»ç¥å¥‡ï¼šå®ƒçŸ¥é“å°è±¡çš„å­—æ®µæœªåˆå§‹åŒ–ï¼Œä½†å®ƒç›¸ä¿¡æ•´å€‹å°åƒå·²åˆå§‹åŒ–ã€‚é€™æ„å‘³è‘—selfä¸€æ—¦æ‰€æœ‰å­—æ®µéƒ½åˆå§‹åŒ–ï¼Œæ‚¨å°±å¯ä»¥å°‡å…¶ç”¨ä½œæ•´å€‹å°è±¡ï¼š

fn use(arg: TwoStrings2):
    pass

struct TwoStrings2:
    var str1: String
    var str2: String

    fn __init__(inout self, cond: Bool, other: String):
        self.str1 = String()
        if cond:
            self.str2 = other
            use(self)  # Safe to use immediately!
            # self.str2.__del__(): destroyed because overwritten below.

        self.str2 = self.str1
        use(self)  # Safe to use immediately!

é¡ä¼¼åœ°ï¼ŒMojo ä¸­çš„åˆå§‹åŒ–å™¨å®Œå…¨è¦†è“‹ æ˜¯å®‰å…¨çš„selfï¼Œä¾‹å¦‚é€šéå§”è¨—çµ¦å…¶ä»–åˆå§‹åŒ–å™¨ï¼š

struct TwoStrings3:
    var str1: String
    var str2: String

    fn __init__(inout self):
        self.str1 = String()
        self.str2 = String()

    fn __init__(inout self, one: String):
        self = TwoStrings3()  # Delegate to the basic init
        self.str1 = one

å’Œownedä¸­åƒæ•¸çš„å­—æ®µç”Ÿå‘½é€±æœŸ__moveinit____del__
ç§»å‹•åˆå§‹å€¼è¨­å®šé …å’Œææ§‹å‡½æ•¸ownedçš„åƒæ•¸å­˜åœ¨æœ€å¾Œä¸€é»é­”åŠ›ã€‚å›é¡§ä¸€ä¸‹ï¼Œé€™äº›æ–¹æ³•ç°½åå¦‚ä¸‹æ‰€ç¤ºï¼š__moveinit__()__del__()

struct TwoStrings:
    ...
    fn __moveinit__(inout self, owned existing: Self):
        # Initializes a new `self` by consuming the contents of `existing`
    fn __del__(owned self):
        # Destroys all resources in `self`

é€™äº›æ–¹æ³•é¢è‡¨ä¸€å€‹æœ‰è¶£ä½†æ™¦æ¾€é›£æ‡‚çš„å•é¡Œï¼šé€™å…©ç¨®æ–¹æ³•éƒ½è² è²¬æ‹†è§£owned existing/selfå€¼ã€‚ä¹Ÿå°±æ˜¯èªªï¼Œ__moveinit__()éŠ·æ¯€ çš„å­å…ƒç´ ä»¥ä¾¿existingå°‡æ‰€æœ‰æ¬Šè½‰ç§»åˆ°æ–°å¯¦ä¾‹ï¼ŒåŒæ™‚__del__()å¯¦ç¾å…¶ çš„åˆªé™¤é‚è¼¯selfã€‚å› æ­¤ï¼Œä»–å€‘éƒ½å¸Œæœ›æ“æœ‰ä¸¦è½‰æ›è©²ownedå€¼çš„å…ƒç´ ï¼Œä¸¦ä¸”ä»–å€‘çµ•å°ä¸å¸Œæœ›è©²ownedå€¼çš„ææ§‹å‡½æ•¸ä¹Ÿé‹è¡Œï¼ˆåœ¨è©²æ–¹æ³•çš„æƒ…æ³ä¸‹__del__()ï¼Œé€™å°‡è®Šæˆç„¡é™å¾ªç’°ï¼‰ã€‚

ç‚ºäº†è§£æ±ºé€™å€‹å•é¡Œï¼ŒMojo å°ˆé–€è™•ç†é€™å…©å€‹æ–¹æ³•ï¼Œå‡è¨­å®ƒå€‘çš„æ•´å€‹å€¼åœ¨å¾æ–¹æ³•è¿”å›æ™‚è¢«éŠ·æ¯€ã€‚é€™æ„å‘³è‘—åœ¨å‚³è¼¸å­—æ®µå€¼ä¹‹å‰å¯ä»¥ä½¿ç”¨æ•´å€‹å°è±¡ã€‚ä¾‹å¦‚ï¼Œé€™å°‡æŒ‰æ‚¨çš„é æœŸå·¥ä½œï¼š

fn consume(owned str: String):
    print('Consumed', str)

struct TwoStrings4:
    var str1: String
    var str2: String

    fn __init__(inout self, one: String):
        self.str1 = one
        self.str2 = String("bar")

    fn __moveinit__(inout self, owned existing: Self):
        self.str1 = existing.str1
        self.str2 = existing.str2

    fn __del__(owned self):
        self.dump() # Self is still whole here
        # Mojo calls self.str2.__del__() since str2 isn't used anymore

        consume(self.str1^)
        # str1 has now been transferred;
        # `self.__del__()` is not called (avoiding an infinite loop).
    
    fn dump(inout self):
        print('str1:', self.str1)
        print('str2:', self.str2)

fn use_two_strings():
    let two_strings = TwoStrings4("foo")

# We use a function call to ensure the `two_strings` ownership is enforced
# (Currently, ownership is not enforced for top-level code in notebooks)
use_two_strings()

str1: foo
str2: bar
Consumed foo
æ‚¨é€šå¸¸ä¸å¿…è€ƒæ…®é€™ä¸€é»ï¼Œä½†å¦‚æœæ‚¨çš„é‚è¼¯å…·æœ‰æŒ‡å‘æˆå“¡çš„å…§éƒ¨æŒ‡é‡ï¼Œå‰‡å¯èƒ½éœ€è¦ä½¿å®ƒå€‘åœ¨ææ§‹å‡½æ•¸æˆ–ç§»å‹•åˆå§‹å€¼è¨­å®šé …æœ¬èº«ä¸­çš„æŸäº›é‚è¼¯ä¸­ä¿æŒæ´»å‹•ç‹€æ…‹ã€‚æ‚¨å¯ä»¥é€šéåˆ†é…_â€œdiscardâ€æ¨¡å¼ä¾†åšåˆ°é€™ä¸€é»ï¼š

fn __del__(owned self):
    self.dump() # Self is still whole here

    consume(self.str1^)
    _ = self.str2
    # self.str2.__del__(): Mojo destroys str2 after its last use.

åœ¨é€™ç¨®æƒ…æ³ä¸‹ï¼Œå¦‚æœä»¥æŸç¨®æ–¹å¼consume()éš±å¼å¼•ç”¨æŸå€‹å€¼str2ï¼Œé€™å°‡ç¢ºä¿str2ç›´åˆ°æœ€å¾Œä¸€æ¬¡ä½¿ç”¨ä¸Ÿæ£„æ¨¡å¼è¨ªå•å®ƒæ™‚æ‰è¢«éŠ·æ¯€_ã€‚

å®šç¾©æ__del__æ§‹å‡½æ•¸
æ‚¨æ‡‰è©²å®šç¾©__del__()æ–¹æ³•ä¾†åŸ·è¡Œé¡å‹æ‰€éœ€çš„ä»»ä½•é¡å‹çš„æ¸…ç†ã€‚é€šå¸¸ï¼Œé€™åŒ…æ‹¬é‡‹æ”¾ä»»ä½•ä¸å¹³å‡¡æˆ–ä¸å¯ç ´å£çš„å­—æ®µçš„å…§å­˜ - ä¸€æ—¦ä¸å†ä½¿ç”¨ä»»ä½•å¹³å‡¡å’Œå¯ç ´å£çš„é¡å‹ï¼ŒMojo å°±æœƒè‡ªå‹•éŠ·æ¯€å®ƒå€‘ã€‚

ä¾‹å¦‚ï¼Œè€ƒæ…®é€™å€‹çµæ§‹ï¼š

from String import String

struct MyPet:
    var name: String
    var age: Int

    fn __init__(inout self, owned name: String, age: Int):
        self.name = name^
        self.age = age

ä¸éœ€è¦å®šç¾©__del__()æ–¹æ³•ï¼Œå› ç‚ºStringå®ƒæ˜¯å¯ç ´å£çš„ï¼ˆå®ƒæœ‰è‡ªå·±çš„__del__()æ–¹æ³•ï¼‰ï¼ŒMojo ä¸€æ—¦ä¸å†ä½¿ç”¨å®ƒï¼ˆå³MyPetä¸å†ä½¿ç”¨å¯¦ä¾‹æ™‚ï¼‰å°±æœƒéŠ·æ¯€å®ƒï¼Œä¸¦ä¸”Intæ˜¯ä¸€å€‹ç°¡å–®çš„é¡å‹ï¼ŒMojo ä¹Ÿæœƒç›¡å¿«å›æ”¶è©²å…§å­˜ï¼ˆå„˜ç®¡æœ‰é»ä¸åŒï¼Œä¸éœ€è¦æ–¹æ³•__del__()ï¼‰ã€‚

ç„¶è€Œï¼Œä»¥ä¸‹çµæ§‹å¿…é ˆå®šç¾©__del__()é‡‹æ”¾ç‚ºå…¶åˆ†é…çš„å…§å­˜çš„æ–¹æ³•Pointerï¼š

struct Array[Type: AnyType]:
    var data: Pointer[Type]
    var size: Int
    var cap: Int

    fn __init__(inout self):
        self.cap = 16
        self.size = 0
        self.data = Pointer[Type].alloc(self.cap)

    fn __init__(inout self, size: Int, value: Type):
        self.cap = size * 2
        self.size = size
        self.data = Pointer[Type].alloc(self.cap)
        for i in range(self.size):
            self.data.store(i, value)

    fn __del__(owned self):
        self.data.free()

ç”Ÿå‘½é€±æœŸ
TODOï¼šè§£é‡‹è¿”å›å¼•ç”¨å¦‚ä½•å·¥ä½œï¼Œèˆ‡èˆ‡åƒæ•¸ç›¸å»åˆçš„ç”Ÿå‘½é€±æœŸç›¸é—œè¯ã€‚è©²åŠŸèƒ½å°šæœªå•Ÿç”¨ã€‚

é¡å‹ç‰¹å¾µ
é€™æ˜¯ä¸€å€‹éå¸¸é¡ä¼¼æ–¼ Rust ç‰¹å¾µæˆ– Swift å”è­°æˆ– Haskell é¡å‹é¡çš„åŠŸèƒ½ã€‚è«‹æ³¨æ„ï¼Œé€™å°šæœªå¯¦æ–½ã€‚

é«˜ç´š/æ™¦æ¾€çš„ Mojo åŠŸèƒ½
æœ¬ç¯€ä»‹ç´¹å°æ–¼æ§‹å»ºæ¨™æº–åº«æœ€åº•å±¤éå¸¸é‡è¦çš„é«˜ç´šç”¨æˆ¶åŠŸèƒ½ã€‚é€™ä¸€ç´šåˆ¥çš„å †æ£§åŒ…å«ä¸€äº›ç‹¹çª„çš„åŠŸèƒ½ï¼Œéœ€è¦å…·å‚™ç·¨è­¯å™¨å…§éƒ¨çš„ç¶“é©—æ‰èƒ½æœ‰æ•ˆåœ°ç†è§£å’Œåˆ©ç”¨ã€‚

@register_passableçµæ§‹è£é£¾å™¨
è™•ç†å€¼çš„é»˜èªæ¨¡å‹æ˜¯å®ƒå€‘å­˜åœ¨æ–¼å…§å­˜ä¸­ï¼Œå› æ­¤å®ƒå€‘å…·æœ‰æ¨™è­˜ï¼Œé€™æ„å‘³è‘—å®ƒå€‘é–“æ¥åœ°å‚³å…¥å’Œå‚³å‡ºå‡½æ•¸ï¼ˆç­‰æ•ˆåœ°ï¼Œå®ƒå€‘åœ¨æ©Ÿå™¨ç´šåˆ¥â€œé€šéå¼•ç”¨â€å‚³éï¼‰ã€‚é€™å°æ–¼ç„¡æ³•ç§»å‹•çš„é¡å‹éå¸¸æœ‰ç”¨ï¼Œä¸¦ä¸”å°æ–¼å¤§å‹å°åƒæˆ–å…·æœ‰æ˜‚è²´è¤‡è£½æ“ä½œçš„äº‹ç‰©ä¾†èªªæ˜¯å®‰å…¨çš„é»˜èªå€¼ã€‚ç„¶è€Œï¼Œå°æ–¼åƒå–®å€‹æ•´æ•¸æˆ–æµ®é»æ•¸é€™æ¨£çš„å¾®å°äº‹ç‰©ä¾†èªªï¼Œå®ƒçš„æ•ˆç‡å¾ˆä½ã€‚

ç‚ºäº†è§£æ±ºé€™å€‹å•é¡Œï¼ŒMojo å…è¨±çµæ§‹é«”é¸æ“‡åœ¨å¯„å­˜å™¨ä¸­å‚³éï¼Œè€Œä¸æ˜¯ä½¿ç”¨è£é£¾å™¨é€šéå…§å­˜å‚³é@register_passableã€‚Intæ‚¨å°‡åœ¨æ¨™æº–åº«ä¸­çš„é¡å‹ä¸Šçœ‹åˆ°æ­¤è£é£¾å™¨ï¼š

@register_passable("trivial")
struct Int:
    var value: __mlir_type.`!pop.scalar<index>`

    fn __init__(value: __mlir_type.`!pop.scalar<index>`) -> Self:
        return Self {value: value}
    ...

åŸºæœ¬@register_passableè£é£¾å™¨ä¸æœƒæ”¹è®Šé¡å‹çš„åŸºæœ¬è¡Œç‚ºï¼šå®ƒä»ç„¶éœ€è¦æœ‰ä¸€å€‹__copyinit__å¯è¤‡åˆ¶çš„æ–¹æ³•ï¼Œå¯èƒ½ä»ç„¶æœ‰ä¸€å€‹__init__and__del__æ–¹æ³•ç­‰ã€‚é€™å€‹è£é£¾å™¨çš„ä¸»è¦å½±éŸ¿æ˜¯åœ¨å…§éƒ¨å¯¦ç¾ç´°ç¯€ä¸Šï¼š@register_passableé¡å‹é€šå¸¸åœ¨æ©Ÿå™¨å¯„å­˜å™¨ä¸­å‚³éï¼ˆå–æ±ºæ–¼åº•å±¤æ¶æ§‹çš„ç´°ç¯€ï¼‰ã€‚

å°æ–¼å…¸å‹çš„ Mojo ç¨‹åºå“¡ä¾†èªªï¼Œé€™å€‹è£é£¾å™¨åªæœ‰ä¸€äº›å¯è§€å¯Ÿåˆ°çš„æ•ˆæœï¼š

@register_passableé¡å‹ç„¡æ³•ä¿å­˜ä¸æ˜¯å…¶æœ¬èº«çš„é¡å‹çš„å¯¦ä¾‹@register_passableã€‚

é¡å‹çš„å¯¦ä¾‹@register_passableä¸å…·æœ‰å¯é æ¸¬çš„æ¨™è­˜ï¼Œå› æ­¤selfæŒ‡é‡ä¸ç©©å®š/ä¸å¯é æ¸¬ï¼ˆä¾‹å¦‚åœ¨å“ˆå¸Œè¡¨ä¸­ï¼‰ã€‚

@register_passableåƒæ•¸å’Œçµæœç›´æ¥æš´éœ²çµ¦ C å’Œ C++ï¼Œè€Œä¸æ˜¯é€šéæŒ‡é‡å‚³éã€‚

é€™ç¨®é¡å‹çš„å’Œæ–¹æ³•æ˜¯éš±å¼éœæ…‹çš„ï¼ˆå°±åƒåœ¨ Python ä¸­ä¸€æ¨£ï¼‰ï¼Œä¸¦æŒ‰å€¼è¿”å›å…¶çµæœ__init__è€Œä¸æ˜¯æ¡ç”¨ã€‚__copyinit____new__inout self

æˆ‘å€‘é è¨ˆè©²è£é£¾å™¨å°‡æ™®éç”¨æ–¼æ ¸å¿ƒæ¨™æº–åº«é¡å‹ï¼Œä½†å°æ–¼ä¸€èˆ¬æ‡‰ç”¨ç¨‹åºç´šä»£ç¢¼å¯ä»¥å®‰å…¨åœ°å¿½ç•¥ã€‚

ä¸Šé¢çš„ä¾‹å­Intå¯¦éš›ä¸Šä½¿ç”¨äº†é€™å€‹è£é£¾å™¨çš„â€œç°¡å–®â€è®Šé«”ã€‚å®ƒæ”¹è®Šç­å¦‚ä¸Šæ‰€è¿°çš„å‚³éç´„å®šï¼Œä½†ä¹Ÿä¸å…è¨±è¤‡è£½å’Œç§»å‹•æ§‹é€ å‡½æ•¸å’Œææ§‹å‡½æ•¸ï¼ˆå°‡å®ƒå€‘å…¨éƒ¨ç°¡å–®åœ°ç¶œåˆèµ·ä¾†ï¼‰ã€‚

TODOï¼šTrivial éœ€è¦èˆ‡å…¶è‡ªå·±çš„è£é£¾å™¨è§£è€¦ï¼Œå› ç‚ºå®ƒä¹Ÿé©ç”¨æ–¼å…§å­˜é¡å‹ã€‚

@always_inlineè£é£¾è€…
@always_inline("nodebug")ï¼šåŒæ¨£çš„äº‹æƒ…ï¼Œä½†æ²’æœ‰èª¿è©¦ä¿¡æ¯ï¼Œå› æ­¤æ‚¨ä¸æœƒé€²å…¥ Int ä¸Šçš„ + æ–¹æ³•ã€‚

@parameterè£é£¾è€…
è£é£¾@parameterå™¨å¯ä»¥æ”¾ç½®åœ¨æ•ç²é‹è¡Œæ™‚å€¼çš„åµŒå¥—å‡½æ•¸ä¸Šï¼Œä»¥å‰µå»ºâ€œåƒæ•¸â€æ•ç²é–‰åŒ…ã€‚é€™æ˜¯ Mojo ä¸­çš„ä¸€å€‹ä¸å®‰å…¨åŠŸèƒ½ï¼Œå› ç‚ºæˆ‘å€‘ç›®å‰æ²’æœ‰å°å¼•ç”¨æ•ç²çš„ç”Ÿå‘½é€±æœŸé€²è¡Œå»ºæ¨¡ã€‚æ­¤åŠŸèƒ½çš„ä¸€å€‹ç‰¹æ®Šæ–¹é¢æ˜¯å®ƒå…è¨±æ•ç²é‹è¡Œæ™‚å€¼çš„é–‰åŒ…ä½œç‚ºåƒæ•¸å€¼å‚³éã€‚

é­”è¡“å¸«
C++ ä»£ç¢¼æœ‰è¨±å¤šèˆ‡å€¼ç”Ÿå‘½é€±æœŸç›¸äº¤çš„ç¥å¥‡é‹ç®—ç¬¦ï¼Œä¾‹å¦‚â€œplacement newâ€ã€â€œplacement deleteâ€å’Œâ€œoperator=â€ï¼Œå®ƒå€‘æœƒåœ¨ç¾æœ‰å€¼ä¸Šé‡æ–°åˆ†é…ã€‚ç•¶æ‚¨ä½¿ç”¨ Mojo çš„æ‰€æœ‰èªè¨€åŠŸèƒ½ä¸¦åœ¨å®‰å…¨çµæ§‹ä¹‹ä¸Šé€²è¡Œçµ„åˆæ™‚ï¼ŒMojo æ˜¯ä¸€ç¨®å®‰å…¨èªè¨€ï¼Œä½†ä»»ä½•å †æ£§éƒ½æ˜¯ C é¢¨æ ¼æŒ‡é‡å’ŒçŒ–ç—çš„ä¸å®‰å…¨æ€§çš„ä¸–ç•Œã€‚Mojo æ˜¯ä¸€ç¨®å¯¦ç”¨èªè¨€ï¼Œç”±æ–¼æˆ‘å€‘å°èˆ‡ C/C++ äº’æ“ä½œä»¥åŠç›´æ¥åœ¨ Mojo æœ¬èº«ä¸­å¯¦ç¾å®‰å…¨çµæ§‹ï¼ˆå¦‚ Stringï¼‰æ„Ÿèˆˆè¶£ï¼Œå› æ­¤æˆ‘å€‘éœ€è¦ä¸€ç¨®æ–¹æ³•ä¾†è¡¨é”ä¸å®‰å…¨çš„äº‹ç‰©ã€‚

Mojo æ¨™æº–åº«Pointer[element_type]é¡å‹æ˜¯é€šé MLIR ä¸­çš„åº•å±¤!pop.pointer<element_type>é¡å‹å¯¦ç¾çš„ï¼Œæˆ‘å€‘å¸Œæœ›æœ‰ä¸€ç¨®æ–¹æ³•åœ¨ Mojo ä¸­å¯¦ç¾é€™äº›èˆ‡ C++ ç­‰æ•ˆçš„ä¸å®‰å…¨çµæ§‹ã€‚æœ€çµ‚ï¼Œé€™äº›å°‡é·ç§»åˆ° Pointer é¡å‹ä¸Šçš„æ‰€æœ‰æ–¹æ³•ï¼Œä½†åœ¨æ­¤ä¹‹å‰ï¼Œæœ‰äº›éœ€è¦ä½œç‚ºå…§ç½®é‹ç®—ç¬¦å…¬é–‹ã€‚

ç›´æ¥è¨ªå• MLIR
Mojo æä¾›å° MLIR æ–¹è¨€å’Œç”Ÿæ…‹ç³»çµ±çš„å®Œå…¨è¨ªå•ã€‚è«‹æŸ¥çœ‹Mojo ä¸­çš„ä½ç´š IRï¼Œäº†è§£å¦‚ä½•ä½¿ç”¨__mlir_typeã€__mlir_opå’Œ__mlir_typeçµæ§‹ã€‚æ‰€æœ‰å…§ç½®å’Œæ¨™æº–åº« API éƒ½æ˜¯é€šéèª¿ç”¨åº•å±¤ MLIR æ§‹é€ ä¾†å¯¦ç¾çš„ï¼Œåœ¨é€™æ¨£åšæ™‚ï¼ŒMojo æœ‰æ•ˆåœ°å……ç•¶äº† MLIR ä¹‹ä¸Šçš„èªæ³•ç³–ã€‚